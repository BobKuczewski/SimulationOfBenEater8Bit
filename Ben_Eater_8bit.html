<!DOCTYPE html>

<html>

<head>
<title>Ben Eater's 8-bit Computer Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<script>
/*
NOP = 0000 XXXX
LDA = 0001 addr
ADD = 0010 addr
SUB = 0011 addr
STA = 0100 addr
LDI = 0101 value
JMP = 0110 addr
JC  = 0111 addr
JZ  = 1000 addr
    = 1001
    = 1010
    = 1011
    = 1100
    = 1101
OUT = 1110 XXXX  // Could use XXXX for In/Out and multiple channels
HLT = 1111 XXXX  // Could use XXXX for other instructions, push, pop, chs, etc.
*/
function decode ( instruction ) {
  let out = "";
  let lower = instruction & 0x0f;
  let upper = (instruction >> 4) & 0x0f;
  if (upper == 0x00) out = ( "NOP " + lower );
  if (upper == 0x01) out = ( "LDA " + lower );
  if (upper == 0x02) out = ( "ADD " + lower );
  if (upper == 0x03) out = ( "SUB " + lower );
  if (upper == 0x04) out = ( "STA " + lower );
  if (upper == 0x05) out = ( "LDI " + lower );
  if (upper == 0x06) out = ( "JMP " + lower );
  if (upper == 0x07) out = ( "JC  " + lower );
  if (upper == 0x08) out = ( "JZ  " + lower );
  if (upper == 0x09) out = ( "?09 " + lower );
  if (upper == 0x0a) out = ( "?0A " + lower );
  if (upper == 0x0b) out = ( "?0B " + lower );
  if (upper == 0x0c) out = ( "?0C " + lower );
  if (upper == 0x0d) out = ( "?0D " + lower );
  if (upper == 0x0e) out = ( "OUT " + lower );
  if (upper == 0x0f) out = ( "HLT " + lower );
  return ( out );
}
var memory = [
  0x1e,  // 00: LDA 14
  0x3c,  // 01: SUB 12
  0x76,  // 02: JC 6
  0x1d,  // 03: LDA 13
  0xe0,  // 04: OUT
  0xf0,  // 05: HLT
  0x4e,  // 06: STA 14
  0x1d,  // 07: LDA 13
  0x2f,  // 08: ADD 15
  0x4d,  // 09: STA 13
  0x60,  // 0A: JMP 0
  0x00,  // 0B:
  0x01,  // 0C: 1
  0x00,  // 0D: (product of x*y)
  0x07,  // 0E: (x)
  0x05   // 0F: (y)
];

var consoleDebug = false;

var red_on = "#ffcc88";
var red_off = "#bb2222";
var yellow_on = "#ffff00";
var yellow_off = "#e0980e";
var blue_on = "#bbccff";
var blue_off = "#162560";
var green_on = "#daff0c";
var green_off = "#185621";

var clock_speed_button = [ [1000,25,16] ];
var clock_speeds = [ 1000, 200, 10 ];
var clock_step_button = [ [true,69,32] ];
var clock_auto_button = [ [false,121,29] ];

var clock_LEDs = [ [false,232,6] ];

var x1_LEDs = [ [true,45,111] ];  // Green near Address Register DIP Switch
var x2_LEDs = [ [true,55,111] ];  // Red near Address Register DIP Switch

var program_ctr_LEDs = [ [false,386,6],
                         [false,395,6],
                         [false,404,6],
                         [false,413,6] ];

var ucode_ctr_LEDs = [ [false,33,395],
                       [false,43,395],
                       [false,53,395] ];

var ucode_state_LEDs = [ [false,66,390],
                         [true,76,390],
                         [true,86,390],
                         [true,97,390],
                         [true,108,390],
                         [false,120,390] ];

//                         [false,124,390],
//                         [false,128,390] ];

var bus_value_LEDs = [ [false,289,6],
                       [true,298,6],
                       [false,307,6],
                       [true,316,6],
                       [false,325,6],
                       [true,334,6],
                       [false,343,6],
                       [true,352,6] ];

var mem_address_LEDs = [ [false,147,145],
                         [true,157,146],
                         [false,166,145],
                         [true,176,146] ];

var register_A_LEDs = [ [false,422,134],
                        [true,432,134],
                        [false,443,134],
                        [true,453,134],
                        [false,464,134],
                        [true,474,134],
                        [false,485,134],
                        [true,495,134] ];

var register_B_LEDs = [ [false,424,290],
                        [true,434,290],
                        [false,445,290],
                        [true,455,290],
                        [false,466,290],
                        [true,477,290],
                        [false,488,290],
                        [true,498,290] ];

var sum_register_LEDs = [ [false,368,220],
                          [true,377,221],
                          [false,389,221],
                          [true,400,222],
                          [false,409,222],
                          [true,419,222],
                          [false,429,222],
                          [true,441,220] ];

var carry_flag_LEDs = [ [true,562,133] ];

var zero_flag_LEDs = [ [true,572,133] ];

var instr_high_LEDs = [ [false,148,369],
                        [true,157,370],
                        [false,166,371],
                        [true,177,371] ];

var instr_low_LEDs = [ [false,187,371],
                       [true,197,371],
                       [false,207,371],
                       [true,217,371] ];

var mem_contents_LEDs = [ [true,138,225],
                          [false,147,225],
                          [true,156,225],
                          [true,166,225],
                          [false,176,225],
                          [true,187,225],
                          [false,198,225],
                          [true,208,225] ];

var control_word_LEDs = [ [true,366,497],
                          [false,376,497],
                          [false,385,497],
                          [true,394,497],
                          [false,403,497],
                          [true,412,497],
                          [false,421,497],
                          [true,430,497],
                          [false,439,497],
                          [true,448,497],
                          [false,457,497],
                          [true,466,497],
                          [false,475,497],
                          [true,484,497],
                          [false,493,497],
                          [true,502,497] ];

function randomize_register_bits ( reg ) {
  for (let i=0; i<reg.length; i++) {
    if (Math.random() > 0.5) {
      reg[i][0] = 1;
    } else {
      reg[i][0] = 0;
    }
  }
}

function randomize_all_bits () {
  randomize_register_bits ( control_word_LEDs );
  randomize_register_bits ( mem_contents_LEDs );
  randomize_register_bits ( instr_low_LEDs );
  randomize_register_bits ( instr_high_LEDs );
  randomize_register_bits ( zero_flag_LEDs );
  randomize_register_bits ( carry_flag_LEDs );
  randomize_register_bits ( sum_register_LEDs );
  randomize_register_bits ( register_B_LEDs );
  // randomize_register_bits ( register_A_LEDs );
  randomize_register_bits ( mem_address_LEDs );
  randomize_register_bits ( bus_value_LEDs );
  // randomize_register_bits ( ucode_state_LEDs );
  // randomize_register_bits ( ucode_ctr_LEDs );
  // randomize_register_bits ( program_ctr_LEDs );
}


var image = new Image();
var image_loaded = false;

function update_canvas() {
  var canvas = document.getElementById('drawing_area');
  if (consoleDebug) console.log ( "update_canvas" );
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;
    if (image_loaded) {
      // Draw the background image
      ctxt.drawImage(image,0,0);

      // Draw the "clock_speed_button"
      ctxt.fillStyle = "#ffffff44";
      if (clock_speed_button[0][0]>=1000) {
        ctxt.fillStyle = "#0000ff44";
      } else if (clock_speed_button[0][0]>=200) {
        ctxt.fillStyle = "#00ff0044";
      } else {
        ctxt.fillStyle = "#ff000044";
      }
      ctxt.fillRect( clock_speed_button[0][1]-20, clock_speed_button[0][2]-20, 20,20);

      // Draw the Run/Stop or "clock_auto_button" button
      ctxt.fillStyle = "#ffffff88";
      if (clock_auto_button[0][0]) {
        ctxt.fillStyle = "#ff888888";
      }
      ctxt.fillRect( clock_auto_button[0][1]-10, clock_auto_button[0][2]-10, 20,20);

      // Draw the Single Step or "clock_step_button" button
      ctxt.fillStyle = "#ffffff88";
      ctxt.fillRect( clock_step_button[0][1]-10, clock_step_button[0][2]-10, 20,20);

      // Draw the Clock light
      for (let i=0; i<clock_LEDs.length; i++) {
        if (clock_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(clock_LEDs[i][1], clock_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the x1 light
      for (let i=0; i<x1_LEDs.length; i++) {
        if (x1_LEDs[i][0]) {
          ctxt.fillStyle = green_on;
        } else {
          ctxt.fillStyle = green_off;
        }
        ctxt.beginPath();
        ctxt.arc(x1_LEDs[i][1], x1_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }
      // Draw the x2 light
      for (let i=0; i<x2_LEDs.length; i++) {
        if (x2_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(x2_LEDs[i][1], x2_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Program Counter
      for (let i=0; i<program_ctr_LEDs.length; i++) {
        if (program_ctr_LEDs[i][0]) {
          ctxt.fillStyle = green_on;
        } else {
          ctxt.fillStyle = green_off;
        }
        ctxt.beginPath();
        ctxt.arc(program_ctr_LEDs[i][1], program_ctr_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Microcode Counter
      for (let i=0; i<ucode_ctr_LEDs.length; i++) {
        if (ucode_ctr_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(ucode_ctr_LEDs[i][1], ucode_ctr_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Microcode State
      for (let i=0; i<ucode_state_LEDs.length; i++) {
        if (ucode_state_LEDs[i][0]) {
          ctxt.fillStyle = green_on;
        } else {
          ctxt.fillStyle = green_off;
        }
        ctxt.beginPath();
        ctxt.arc(ucode_state_LEDs[i][1], ucode_state_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Bus lights
      for (let i=0; i<bus_value_LEDs.length; i++) {
        if (bus_value_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(bus_value_LEDs[i][1], bus_value_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Memory Address lights
      for (let i=0; i<mem_address_LEDs.length; i++) {
        if (mem_address_LEDs[i][0]) {
          ctxt.fillStyle = yellow_on;
        } else {
          ctxt.fillStyle = yellow_off;
        }
        ctxt.beginPath();
        ctxt.arc(mem_address_LEDs[i][1], mem_address_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the A Register lights
      for (let i=0; i<register_A_LEDs.length; i++) {
        if (register_A_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(register_A_LEDs[i][1], register_A_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the B Register lights
      for (let i=0; i<register_B_LEDs.length; i++) {
        if (register_B_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(register_B_LEDs[i][1], register_B_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Sum Register lights
      for (let i=0; i<sum_register_LEDs.length; i++) {
        if (sum_register_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(sum_register_LEDs[i][1], sum_register_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Carry Flag light
      for (let i=0; i<carry_flag_LEDs.length; i++) {
        if (carry_flag_LEDs[i][0]) {
          ctxt.fillStyle = green_on;
        } else {
          ctxt.fillStyle = green_off;
        }
        ctxt.beginPath();
        ctxt.arc(carry_flag_LEDs[i][1], carry_flag_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Zero Flag light
      for (let i=0; i<zero_flag_LEDs.length; i++) {
        if (zero_flag_LEDs[i][0]) {
          ctxt.fillStyle = green_on;
        } else {
          ctxt.fillStyle = green_off;
        }
        ctxt.beginPath();
        ctxt.arc(zero_flag_LEDs[i][1], zero_flag_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Instruction Register High lights
      for (let i=0; i<instr_high_LEDs.length; i++) {
        if (instr_high_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(instr_high_LEDs[i][1], instr_high_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Instruction Register Low lights
      for (let i=0; i<instr_low_LEDs.length; i++) {
        if (instr_low_LEDs[i][0]) {
          ctxt.fillStyle = yellow_on;
        } else {
          ctxt.fillStyle = yellow_off;
        }
        ctxt.beginPath();
        ctxt.arc(instr_low_LEDs[i][1], instr_low_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Memory Contents lights
      for (let i=0; i<mem_contents_LEDs.length; i++) {
        if (mem_contents_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(mem_contents_LEDs[i][1], mem_contents_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Control Word lights
      for (let i=0; i<control_word_LEDs.length; i++) {
        if (control_word_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(control_word_LEDs[i][1], control_word_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }


      // ctxt.fillStyle = "#ff8888";
      // ctxt.fillRect((w/2)-10,(h/2)-10,20,20);

    };
  }
}

function setup_canvas() {
  var canvas = document.getElementById('drawing_area');
  if (consoleDebug) console.log ( "setup_canvas" );
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;

    image.onload = function () {
      image_loaded = true;

      // Draw the background image
      ctxt.drawImage(image,0,0);

      update_canvas();
    };
    image.src = 'computer_background_640.png';
  }
}

function draw_canvas() {
  // window.alert ( "Draw Canvas" );
  var drawing_area = document.getElementById ( "drawing_area" );
  if (drawing_area != null) {
    var ctxt = drawing_area.getContext("2d");
    var w = drawing_area.width;
    var h = drawing_area.height;

    image.onload = function () {
        ctxt.drawImage(image,5,5);
    };

  }
}

function mouse_up ( event ) {
  if ( (event.clientX >= clock_step_button[0][1]) && (event.clientX <= clock_step_button[0][1]+20) ) {
    if ( (event.clientY >= clock_step_button[0][2]) && (event.clientY <= clock_step_button[0][2]+20) ) {
      if (consoleDebug) console.log ( "Clock up with " + event.clientX + ", " + event.clientY );
      step();
      update_canvas();
    }
  }
}

function mouse_down ( event ) {
  if ( (event.clientX >= clock_step_button[0][1]) && (event.clientX <= clock_step_button[0][1]+20) ) {
    if ( (event.clientY >= clock_step_button[0][2]) && (event.clientY <= clock_step_button[0][2]+20) ) {
      if (consoleDebug) console.log ( "Clock down with " + event.clientX + ", " + event.clientY );
      step();
      update_canvas();
    }
  }
  if ( (event.clientX >= clock_auto_button[0][1]) && (event.clientX <= clock_auto_button[0][1]+20) ) {
    if ( (event.clientY >= clock_auto_button[0][2]) && (event.clientY <= clock_auto_button[0][2]+20) ) {
      run_stop();
      clock_auto_button[0][0] = !clock_auto_button[0][0];
      if (consoleDebug) console.log ( "auto toggled to " + clock_auto_button[0][0] );
      update_canvas();
    }
  }
  if ( (event.clientX >= clock_speed_button[0][1]-10) && (event.clientX <= clock_speed_button[0][1]+10) ) {
    if ( (event.clientY >= clock_speed_button[0][2]-10) && (event.clientY <= clock_speed_button[0][2]+10) ) {
      if (consoleDebug) console.log ( "toggle speed button pressed" );
      for (let i=0; i<clock_speeds.length; i++) {
        if (consoleDebug) console.log ( "Checking speed " + i + ": " + clock_speeds[i] );
        if (clock_speed_button[0][0] == clock_speeds[i]) {
          if (consoleDebug) console.log ( "toggle speed" );
          if (i < (clock_speeds.length-1)) {
            clock_speed_button[0][0] = clock_speeds[i+1];
          } else {
            clock_speed_button[0][0] = clock_speeds[0];
          }
          if (consoleDebug) console.log ( "toggled speed to " + clock_speed_button[0][0] );
          break;
        }
      }
      update_canvas();
    }
  }

}

stopRunning = false;
function mainLoop()
{
   if (consoleDebug) console.log("sim: enter mainLoop");

   if (mainLoop.bInMainLoop)
      return;

   mainLoop.bInMainLoop = true;
   mainLoop.bStayInLoop = false;    // by default, release main loop

   if (typeof mainLoop.nCounter == "undefined")
      mainLoop.nCounter = 0;

   if (!stopRunning) {
	   exec_next();
   }

   ++mainLoop.nCounter;

   mainLoop.bStayInLoop = true;

   if (stopRunning)
	  mainLoop.bStayInLoop = false;

   mainLoop.bInMainLoop = false;

   if (mainLoop.bStayInLoop)
      setTimeout ("mainLoop()", clock_speed_button[0][0]); // Call mainLoop 1ms from now

   if (consoleDebug) console.log("sim: exit mainLoop");

   return mainLoop.bStayInLoop;
} // mainLoop

running = false;
run_counter = 1;
function run_stop() {
	running = !running;
	if (running) {
//x		document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
//x		document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
		run();
	} else {
//x		document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
//x		document.getElementById('RunStop').setAttribute("style", "");
		stop();
//x		if (consoleDebug) console.log ( "Opcodes Used:" );
//x		for (i=0; i<16; i++) {
//x			s = " " + hex2(i) + ":  ";
//x			for (j=0; j<16; j++) {
//x				s += " " + hex1(used_ops[(16*i)+j]);
//x			}
//x			if (consoleDebug) console.log ( s + "\n" );
//x		}
		// if (consoleDebug) console.log ( "Used:\n" + used_ops );
	}
}
function run() {
	stopRunning = false;
	mainLoop.nCounter = 0;
	mainLoop();
}
function stop() {
	running = false;
	mainLoop.bStayInLoop = false;
	stopRunning = true;
}
function step() {
	if (running == false) {
		exec_next();
	}
}

function put ( value, register ) {
  let n = register.length;
  bit = 0;
  for (let i=0; i<n; i++) {
    if ((value & (0x01 << bit)) > 0) {
      register[n-(i+1)][0] = true;
    } else {
      register[n-(i+1)][0] = false;
    }
    bit = bit + 1;
  }
}

var count = 0;
function exec_next() {

  // Toggle the clock
  clock_LEDs[0][0] = !clock_LEDs[0][0];

  // Update the ucode counter on the appropriate clock edge
  if (!clock_LEDs[0][0]) {
    ucode_ctr_LEDs[0][0] = !ucode_ctr_LEDs[0][0];
    if (!ucode_ctr_LEDs[0][0]) {
      ucode_ctr_LEDs[1][0] = !ucode_ctr_LEDs[1][0];
      if (!ucode_ctr_LEDs[1][0]) {
        ucode_ctr_LEDs[2][0] = !ucode_ctr_LEDs[2][0];
      }
    }
  }

  // Update the ucode state based on the counter
  let ucv = 0;
  if (ucode_ctr_LEDs[2][0]) {
    ucv = ucv | 0x04;
  }
  if (ucode_ctr_LEDs[1][0]) {
    ucv = ucv | 0x02;
  }
  if (ucode_ctr_LEDs[0][0]) {
    ucv = ucv | 0x01;
  }
  if (ucv > 5) {
    ucv = 0;
    ucode_ctr_LEDs[0][0] = false;
    ucode_ctr_LEDs[1][0] = false;
    ucode_ctr_LEDs[2][0] = false;
  }
  ucode_state_LEDs[0][0] = true;
  ucode_state_LEDs[1][0] = true;
  ucode_state_LEDs[2][0] = true;
  ucode_state_LEDs[3][0] = true;
  ucode_state_LEDs[4][0] = true;
  ucode_state_LEDs[5][0] = true;
  ucode_state_LEDs[ucv][0] = false;

  console.log ( "ucv before pc = " + ucv );
  if ( (clock_LEDs[0][0]) && (ucv == 3) ) {
    // Execute the current instruction
    let pc = 0;
    if (program_ctr_LEDs[0][0]) {
      pc = pc | 0x08;
    }
    if (program_ctr_LEDs[1][0]) {
      pc = pc | 0x04;
    }
    if (program_ctr_LEDs[2][0]) {
      pc = pc | 0x02;
    }
    if (program_ctr_LEDs[3][0]) {
      pc = pc | 0x01;
    }
    console.log ( "Execute " + memory[pc] + " = " + decode(memory[pc]) );

    let lower = memory[pc] & 0x0f;
    let upper = (memory[pc] >> 4) & 0x0f;

    if (upper == 0x00)        { // "NOP " + lower );
    } else if (upper == 0x01) { // "LDA " + lower );
      let value = memory[lower];
      put ( value, register_A_LEDs );
    } else if (upper == 0x02) { // "ADD " + lower );
    } else if (upper == 0x03) { // "SUB " + lower );
      // let value = get ( register_

    } else if (upper == 0x04) { // "STA " + lower );
    } else if (upper == 0x05) { // "LDI " + lower );
    } else if (upper == 0x06) { // "JMP " + lower );
    } else if (upper == 0x07) { // "JC  " + lower );
    } else if (upper == 0x08) { // "JZ  " + lower );
    } else if (upper == 0x09) { // "?09 " + lower );
    } else if (upper == 0x0a) { // "?0A " + lower );
    } else if (upper == 0x0b) { // "?0B " + lower );
    } else if (upper == 0x0c) { // "?0C " + lower );
    } else if (upper == 0x0d) { // "?0D " + lower );
    } else if (upper == 0x0e) { // "OUT " + lower );
    } else if (upper == 0x0f) { // "HLT " + lower );
    }

    // Increment the program counter as needed
    pc = pc + 1;
    console.log ( "PC = " + pc );
    program_ctr_LEDs[0][0] = ( (pc & 0x08) != 0 );
    program_ctr_LEDs[1][0] = ( (pc & 0x04) != 0 );
    program_ctr_LEDs[2][0] = ( (pc & 0x02) != 0 );
    program_ctr_LEDs[3][0] = ( (pc & 0x01) != 0 );
  }

  // Set all others to random values (used during development)
  randomize_all_bits();
  update_canvas();

	if (consoleDebug) console.log ( "Executed " + count );
	count = count + 1;
}

function cpu_reset() {
	is_idle = false;
	running = true;
	stopRunning = true;
	run_stop();
	stop();
	run_counter = 1;
	mainLoop.nCounter = 0;
}


window.onload = setup_canvas;

setup_canvas();

</script>

</head>

<body id='page' onload="setup_canvas()" onresize="update_canvas()" bgcolor="lightblue">
<!--body id='page' bgcolor="lightblue"-->

<canvas id="drawing_area" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)"></canvas>

</body>
