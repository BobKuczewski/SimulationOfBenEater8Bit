<!DOCTYPE html>

<html>

<head>
<title>Ben Eater's 8-bit Computer Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<script>


/* Instruction set:
NOP = 0000 XXXX
LDA = 0001 addr
ADD = 0010 addr
SUB = 0011 addr
STA = 0100 addr
LDI = 0101 value
JMP = 0110 addr
JC  = 0111 addr
JZ  = 1000 addr
    = 1001
    = 1010
    = 1011
    = 1100
    = 1101
OUT = 1110 XXXX  // Could use XXXX for In/Out and multiple channels
HLT = 1111 XXXX  // Could use XXXX for other instructions, push, pop, chs, etc.
*/

var memory = [ // Fibonacci Numbers up to 144
/* 0 */ 0x51,  // ldi 1   ; 1
/* 1 */ 0x4e,  // sta e   ; y(e) = 1
/* 2 */ 0x50,  // ldi 0   ; x = 0
/* 3 */ 0x2e,  // add [e] ; x + y
/* 4 */ 0x4f,  // sta [f] ; z = x + y
/* 5 */ 0x1e,  // lda [e] ; y
/* 6 */ 0x4d,  // sta [d] ; x = y
/* 7 */ 0x1f,  // lda [f] ; z
/* 8 */ 0x4e,  // sta [e] ; y = z
/* 9 */ 0x1d,  // lda [d] ; x
/* a */ 0xe0,  // out
/* b */ 0x70,  // jc  0   ; jump carry to next Fib
/* c */ 0x63,  // jmp 3   ; keep adding
/* d */ 0x00,  // x
/* e */ 0x00,  // y
/* f */ 0x00,  // z
];


function hex1 ( v ) {
	return ( (v % 16).toString(16).toUpperCase() );
}

function hex2 ( v ) {
	h = (v % 256).toString(16).toUpperCase();
	while (h.length < 2) {
		h = "0" + h;
	}
	return ( h );
}

function hex4 ( v ) {
	h = (v % 65536).toString(16).toUpperCase();
	while (h.length < 4) {
		h = "0" + h;
	}
	return ( h );
}

function display_status() {
  let txt = "";
  let next_instr = document.getElementById('next_instruction');
  let npc = prog_ctr.get_value();
  let no = memory[npc];
  txt = "Next:\n " + hex2(npc) + ":" + hex2(no) + " " + decode(no) + "\n";
  next_instr.innerHTML = txt;

  let mem_disp = document.getElementById('mem_status');
  txt = "  Memory\n";
  for (let i=0; i<memory.length; i++) {
    let p = "";
    if (i == npc) {
      p = " <<---";
    }
    txt = txt + "  " + hex1(i) + " " + hex2(memory[i]) + p + "\n";
  }
  mem_disp.innerHTML = txt;
}

//var memory = [
//* 0 */ 0x1e,  // LDA E (ff)
//* 1 */ 0x55,  // LDI 5
//* 2 */ 0x2f,  // ADD F 5
//* 3 */ 0x3d,  // SUB F 1
//* 4 */ 0xf0,  // HLT
//* 5 */ 0x60,  // JMP 0
//* 6 */ 0x00,
//* 7 */ 0x00,
//* 8 */ 0x00,
//* 9 */ 0x00,
//* a */ 0x00,
//* b */ 0x00,
//* c */ 0x00,
//* d */ 0x01,
//* e */ 0xff,
//* f */ 0x05,
//];

/* Program to shift A along (works)
  0x18,
  0x19,
  0x1a,
  0x1b,
  0x1c,
  0x1d,
  0x1e,
  0x60, // Jump 0
  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80
*/
/* Program to multiply?
  0x1e,  // 00: LDA 14
  0x3c,  // 01: SUB 12
  0x76,  // 02: JC 6
  0x1d,  // 03: LDA 13
  0xe0,  // 04: OUT
  0xf0,  // 05: HLT
  0x4e,  // 06: STA 14
  0x1d,  // 07: LDA 13
  0x2f,  // 08: ADD 15
  0x4d,  // 09: STA 13
  0x60,  // 0A: JMP 0
  0x00,  // 0B:
  0x01,  // 0C: 1
  0x00,  // 0D: (product of x*y)
  0x07,  // 0E: (x)
  0x05   // 0F: (y)
*/

/*
// Program to shift A to the left
  0x18,  // 00: LDA 14
  0x19,
  0x1a,
  0x1b,
  0x1c,
  0x1d,
  0x1e,
  0x1f,

  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80
*/
function change_example() {
  if (document.getElementById("examples").value == "Examples") {
    memory = [ // Halt
    /* 0 */ 0xff,
    /* 1 */ 0xff,
    /* 2 */ 0xff,
    /* 3 */ 0xff,
    /* 4 */ 0xff,
    /* 5 */ 0xff,
    /* 6 */ 0xff,
    /* 7 */ 0xff,
    /* 8 */ 0xff,
    /* 9 */ 0xff,
    /* a */ 0xff,
    /* b */ 0xff,
    /* c */ 0xff,
    /* d */ 0xff,
    /* e */ 0xff,
    /* f */ 0xff,
    ];
  } else if (document.getElementById("examples").value == "No Ops") {
    memory = [ // No Ops
    /* 0 */ 0,
    /* 1 */ 0,
    /* 2 */ 0,
    /* 3 */ 0,
    /* 4 */ 0,
    /* 5 */ 0,
    /* 6 */ 0,
    /* 7 */ 0,
    /* 8 */ 0,
    /* 9 */ 0,
    /* a */ 0,
    /* b */ 0,
    /* c */ 0,
    /* d */ 0,
    /* e */ 0,
    /* f */ 0,
    ];
  } else if (document.getElementById("examples").value == "Counter") {
    memory = [ // Count forever
    /* 0 */ 0x51,  // ldi 1   ; 1
    /* 1 */ 0x4f,  // sta f   ; r[f] = 1
    /* 2 */ 0x50,  // ldi 0   ; a = 0
    /* 3 */ 0x2f,  // add [f] ; a = a + 1
    /* 4 */ 0xe0,  // out     ;
    /* 5 */ 0x63,  // jmp 3   ;
    /* 6 */ 0x4d,  // sta [d] ; x = y
    /* 7 */ 0x1f,  // lda [f] ; z
    /* 8 */ 0x4e,  // sta [e] ; y = z
    /* 9 */ 0x1d,  // lda [d] ; x
    /* a */ 0xe0,  // out
    /* b */ 0x70,  // jc  0   ; jump carry to next Fib
    /* c */ 0x63,  // jmp 3   ; keep adding
    /* d */ 0x00,  // x
    /* e */ 0x00,  // y
    /* f */ 0x00,  // value
    ];
  } else if (document.getElementById("examples").value == "Fibonacci") {
    memory = [ // Fibonacci Numbers up to 144
    /* 0 */ 0x51,  // ldi 1   ; 1
    /* 1 */ 0x4e,  // sta e   ; y(e) = 1
    /* 2 */ 0x50,  // ldi 0   ; x = 0
    /* 3 */ 0x2e,  // add [e] ; x + y
    /* 4 */ 0x4f,  // sta [f] ; z = x + y
    /* 5 */ 0x1e,  // lda [e] ; y
    /* 6 */ 0x4d,  // sta [d] ; x = y
    /* 7 */ 0x1f,  // lda [f] ; z
    /* 8 */ 0x4e,  // sta [e] ; y = z
    /* 9 */ 0x1d,  // lda [d] ; x
    /* a */ 0xe0,  // out
    /* b */ 0x70,  // jc  0   ; jump carry to next Fib
    /* c */ 0x63,  // jmp 3   ; keep adding
    /* d */ 0x00,  // x
    /* e */ 0x00,  // y
    /* f */ 0x00,  // z
    ];
  }
  display_status();
}


var consoleDebug = false;

var gray_on = "#cccccc";
var gray_off = "#444444";
var red_on = "#ffcc88";
var red_off = "#bb2222";
var yellow_on = "#ffff00";
var yellow_off = "#e0980e";
var blue_on = "#bbccff";
var blue_off = "#162560";
var green_on = "#daff0c";
var green_off = "#185621";

function toggle_debug() {
  let debug = document.getElementById('debug');
  consoleDebug = debug.checked;
}

class Register {
  constructor ( name, nbits ) {
    if (consoleDebug) console.log ( "New Register " + name );
    this.nbits = nbits;
    this.reg_name = name;
    this.on_color = gray_on;
    this.off_color = gray_off;
    this.radius = 10;
    this.state = [ true ];
    this.position = [ [20,90] ];
  }
  get_state() {
    return ( this.state );
  }
  get_value() {
    let value = 0;
    let n = this.state.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      if (this.state[i]) {
        value = value | (0x01 << bit);
      }
      bit = bit - 1;
    }
    value = value & ((2**this.nbits)-1);
    return ( value );
  }
  set_value ( value ) {
    // The register indexes are bit positions, so reverse
    // value = 1101  gives [ 1, 0, 1, 1 ]
    value = value & 0xff;
    this.state = [];
    let n = this.position.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      // if ((value >> bit) & 0x01) > 0) {
      if ((value & (0x01 << bit)) > 0) {
        this.state.push ( true );
      } else {
        this.state.push ( false );
      }
      bit = bit - 1;
    }
  }
  randomize_bits () {
    for (let i=0; i<this.state.length; i++) {
      if (Math.random() > 0.5) {
        this.state[i] = true;
      } else {
        this.state[i] = false;
      }
    }
  }
  draw ( ctxt ) {
    // console.log ( "Draw Register " + this.reg_name );
    // Draw the Register lights
    for (let i=0; i<this.position.length; i++) {
      let s = false;
      if (i < this.state.length) {
        s = this.state[i];
      }
      if (s) {
        ctxt.fillStyle = this.on_color;
      } else {
        ctxt.fillStyle = this.off_color;
      }
      ctxt.beginPath();
      ctxt.arc(this.position[i][0], this.position[i][1], this.radius, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }
  toString() {
    let s = "Register " + this.reg_name + " = " + this.get_value();
    return ( s );
  }
}

class ClockModule extends Register {

  constructor (name,nbits) {
    super(name,nbits);
    this.reset();
  }

  reset() {
    this.state = false;
    this.reset_button = [ [false,32,344] ];
    this.clock_speed_button = [ [200,25,16] ];
    this.clock_run_stop_button = [ [false,121,29] ];
    this.clock_step_button = [ [true,69,32] ];
    this.clock_speeds = [ 1000, 200, 2 ];
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.position = [ 232, 6 ];
    this.radius = 5;
    // console.log ( "Update Canvas" );
    // update_canvas();
  }

  half_tick() {
    this.state = ! this.state;
  }

  get_speed_ms() {
    return ( this.clock_speed_button[0][0] );
  }

  mouse_up ( event ) {
    if ( (event.clientX >= this.clock_step_button[0][1]) && (event.clientX <= this.clock_step_button[0][1]+20) ) {
      if ( (event.clientY >= this.clock_step_button[0][2]) && (event.clientY <= this.clock_step_button[0][2]+20) ) {
        // if (consoleDebug) console.log ( "Clock up with " + event.clientX + ", " + event.clientY );
        step();
        update_canvas();
      }
    }
  }

  mouse_down ( event ) {
    if ( (event.clientX >= this.reset_button[0][1]) && (event.clientX <= this.reset_button[0][1]+20) ) {
      if ( (event.clientY >= this.reset_button[0][2]) && (event.clientY <= this.reset_button[0][2]+20) ) {
        // if (consoleDebug) console.log ( "Reset down with " + event.clientX + ", " + event.clientY );
        this.clock_run_stop_button[0][0] = false;
        cpu_reset();
        this.state = false;
        clock.set_value(false);
        ucode_ctr.set_value(0);
        prog_ctr.set_value(0);
        mem_addr.set_value(0);
        mem_data.set_value(0);
        inst_op.set_value(0);
        inst_data.set_value(0);
        a_reg.set_value(0);
        b_reg.set_value(0);
        sum_reg.set_value(0);
        carry_bit.set_value(0);
        zero_bit.set_value(0);
        display_out.set_value(0);
        display_out.set_digits ("0");
        update_canvas();
      }
    }
    if ( (event.clientX >= this.clock_step_button[0][1]) && (event.clientX <= this.clock_step_button[0][1]+20) ) {
      if ( (event.clientY >= this.clock_step_button[0][2]) && (event.clientY <= this.clock_step_button[0][2]+20) ) {
        // if (consoleDebug) console.log ( "Clock down with " + event.clientX + ", " + event.clientY );
        step();
        update_canvas();
      }
    }
    if ( (event.clientX >= this.clock_run_stop_button[0][1]) && (event.clientX <= this.clock_run_stop_button[0][1]+20) ) {
      if ( (event.clientY >= this.clock_run_stop_button[0][2]) && (event.clientY <= this.clock_run_stop_button[0][2]+20) ) {
        run_stop();
        this.clock_run_stop_button[0][0] = !this.clock_run_stop_button[0][0];
        // if (consoleDebug) console.log ( "auto toggled to " + this.clock_run_stop_button[0][0] );
        update_canvas();
      }
    }
    if ( (event.clientX >= this.clock_speed_button[0][1]-10) && (event.clientX <= this.clock_speed_button[0][1]+10) ) {
      if ( (event.clientY >= this.clock_speed_button[0][2]-10) && (event.clientY <= this.clock_speed_button[0][2]+10) ) {
        // if (consoleDebug) console.log ( "toggle speed button pressed" );
        for (let i=0; i<this.clock_speeds.length; i++) {
          // if (consoleDebug) console.log ( "Checking speed " + i + ": " + this.clock_speeds[i] );
          if (this.clock_speed_button[0][0] == this.clock_speeds[i]) {
            // if (consoleDebug) console.log ( "toggle speed" );
            if (i < (this.clock_speeds.length-1)) {
              this.clock_speed_button[0][0] = this.clock_speeds[i+1];
            } else {
              this.clock_speed_button[0][0] = this.clock_speeds[0];
            }
            // if (consoleDebug) console.log ( "toggled speed to " + this.clock_speed_button[0][0] );
            break;
          }
        }
        update_canvas();
      }
    }
  }

  draw(ctxt) {
    // Draw the "clock_speed_button"
    ctxt.fillStyle = "#ffffff44";
    if (this.clock_speed_button[0][0]>=1000) {
      ctxt.fillStyle = "#0000ff44";
    } else if (this.clock_speed_button[0][0]>=200) {
      ctxt.fillStyle = "#00ff0044";
    } else {
      ctxt.fillStyle = "#ff000044";
    }
    ctxt.fillRect( this.clock_speed_button[0][1]-20, this.clock_speed_button[0][2]-20, 20,20);

    // Draw the Run/Stop or "clock_run_stop_button" button
    ctxt.fillStyle = "#ffffff88";
    if (this.clock_run_stop_button[0][0]) {
      ctxt.fillStyle = "#ff888888";
    }
    ctxt.fillRect( this.clock_run_stop_button[0][1]-10, this.clock_run_stop_button[0][2]-10, 20,20);

    // Draw the Single Step or "clock_step_button" button
    ctxt.fillStyle = "#ffffff88";
    ctxt.fillRect( this.clock_step_button[0][1]-10, this.clock_step_button[0][2]-10, 20,20);

    // Draw the Reset "reset_button" button
    ctxt.fillStyle = "#ffffff88";
    ctxt.fillRect( this.reset_button[0][1]-10, this.reset_button[0][2]-10, 20,20);

    // Draw the Clock LED
    if (this.state) {
      ctxt.fillStyle = blue_on;
    } else {
      ctxt.fillStyle = blue_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0], this.position[1], 5, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class uCodeCounter extends Register {

  constructor (name,nbits) {
    super("uCodeCounter",nbits);
    this.state = 0;
    this.ucode_ctr_LEDs = [ [false,33,395],[false,43,395],[false,53,395] ];
    this.ucode_state_LEDs = [ [false,66,390],
                              [true,76,390],
                              [true,86,390],
                              [true,97,390],
                              [true,108,390],
                              [true,120,390] ];
    //                        [false,124,390],
    //                        [false,128,390] ];
  }

  reset() {
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      this.ucode_ctr_LEDs[i][0] = false;
    }
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      this.ucode_state_LEDs[i][0] = true;
    }
    this.ucode_state_LEDs[0][0] = false;
  }

  update ( clock_state ) {
    // Update the ucode counter on the appropriate clock edge
    if (!clock_state) {
      this.ucode_ctr_LEDs[0][0] = !this.ucode_ctr_LEDs[0][0];
      if (!this.ucode_ctr_LEDs[0][0]) {
        this.ucode_ctr_LEDs[1][0] = !this.ucode_ctr_LEDs[1][0];
        if (!this.ucode_ctr_LEDs[1][0]) {
          this.ucode_ctr_LEDs[2][0] = !this.ucode_ctr_LEDs[2][0];
        }
      }
    }

    // Update the ucode state based on the counter
    this.state = 0;
    if (this.ucode_ctr_LEDs[2][0]) {
      this.state = this.state | 0x04;
    }
    if (this.ucode_ctr_LEDs[1][0]) {
      this.state = this.state | 0x02;
    }
    if (this.ucode_ctr_LEDs[0][0]) {
      this.state = this.state | 0x01;
    }
    if (this.state > 5) {
      this.state = 0;
      this.ucode_ctr_LEDs[0][0] = false;
      this.ucode_ctr_LEDs[1][0] = false;
      this.ucode_ctr_LEDs[2][0] = false;
    }
    this.ucode_state_LEDs[0][0] = true;
    this.ucode_state_LEDs[1][0] = true;
    this.ucode_state_LEDs[2][0] = true;
    this.ucode_state_LEDs[3][0] = true;
    this.ucode_state_LEDs[4][0] = true;
    this.ucode_state_LEDs[5][0] = true;
    this.ucode_state_LEDs[this.state][0] = false;

    // console.log ( "this.state before pc = " + this.state );
    return ( this.state );
  }

  draw_ucode_ctr ( ctxt ) {
    // Draw the Microcode Counter
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      if (this.ucode_ctr_LEDs[i][0]) {
        ctxt.fillStyle = red_on;
      } else {
        ctxt.fillStyle = red_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_ctr_LEDs[i][1], this.ucode_ctr_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw_ucode_state ( ctxt ) {
    // Draw the Microcode State
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      if (this.ucode_state_LEDs[i][0]) {
        ctxt.fillStyle = green_on;
      } else {
        ctxt.fillStyle = green_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_state_LEDs[i][1], this.ucode_state_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw(ctxt) {
    this.draw_ucode_ctr ( ctxt );
    this.draw_ucode_state ( ctxt );
  }
}


class ARegister extends Register {
  constructor (name,nbits) {
    super("A Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [ true, false, true, false, false, false, true, true ];
    this.position = [ [422,134],[432,134],[443,134],[453,134],[464,134],[474,134],[485,134],[495,134] ];
  }
}


class BRegister extends Register {
  constructor (name,nbits) {
    super("B Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [424,290],[434,290],[445,290],[455,290],[466,290],[477,290],[488,290],[498,290] ];
  }
}


class SumRegister extends Register {
  constructor (name,nbits) {
    super("Sum Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [368,220],[377,221],[389,221],[400,222],[409,222],[419,222],[429,222],[441,220] ];
  }
}

class CarryRegister extends Register {
  constructor (name,nbits) {
    super("Carry Bit",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [562,133] ];
  }
}

class ZeroRegister extends Register {
  constructor (name,nbits) {
    super("Zero Bit",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [572,133] ];
  }
}


class ProgramCounter extends Register {
  constructor (name,nbits) {
    super("Program Counter",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [386,6], [395,6], [404,6], [413,6] ];
  }
}


class InstructionOperation extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [true,false,false,false];
    this.position = [ [148,369], [157,370], [166,371], [177,371] ];
  }
}
class InstructionData extends Register {
  constructor (name,nbits) {
    super("Instruction Data",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,true];
    this.position = [ [187,371], [197,371], [207,371], [217,371] ];
  }
}


class MemoryAddress extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [147,145], [157,146], [166,145], [176,146] ];
  }
}

class MemoryData extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false];
    this.position = [ [138,225], [147,225], [156,225], [166,225], [176,225], [187,225], [198,225], [208,225] ];
  }
}


class SevenSegmentDisplay extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.digits = "0";
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [true,true,true,true,true,true,true];
    let off = 35;
    this.position = [ [565+off,333], [578+off,332], [576+off,343], [574+off,355], [561+off,355], [563+off,343] ];
    this.segments = [ [0,1], [1,2], [2,3], [3,4], [4,5], [5,0], [2,5] ];
    this.digit_segments = [
      /* 0 */ [0,1,2,3,4,5],
      /* 1 */ [1,2],
      /* 2 */ [0,1,6,4,3],
      /* 3 */ [0,1,2,3,6],
      /* 4 */ [1,2,5,6],
      /* 5 */ [0,2,3,5,6],
      /* 6 */ [0,2,3,4,5,6],
      /* 7 */ [0,1,2],
      /* 8 */ [0,1,2,3,4,5,6],
      /* 9 */ [0,1,2,3,5,6],
    ];
  }

  set_digits ( digits ) {
    this.digits = digits;
  }

  draw_digit ( ctxt, d, offset ) {
    let segs = this.digit_segments[d];
    ctxt.strokeStyle = "#fd4a57";
    ctxt.lineWidth = 3;
    for (let i=0; i<segs.length; i++) {
      let seg = this.segments[segs[i]]
      let start = this.position[seg[0]];
      let end   = this.position[seg[1]];
      ctxt.beginPath();
      ctxt.moveTo(offset+start[0], start[1]);
      ctxt.lineTo(offset+end[0], end[1]);
      ctxt.stroke();
    }
  }

  draw(ctxt) {
    if (this.digits.length > 0) {
      for (let i=0; i<this.digits.length; i++) {
        let shft = this.digits.length - (i+1);
        let offset = -22 * shft;
        this.draw_digit ( ctxt, this.digits[i], offset );
      }
    }
  }
}


function decode ( instruction ) {
  let out = "";
  let lower = instruction & 0x0f;
  let upper = (instruction >> 4) & 0x0f;
  if (upper == 0x00) out = ( "NOP " + lower );
  if (upper == 0x01) out = ( "LDA " + lower );
  if (upper == 0x02) out = ( "ADD " + lower );
  if (upper == 0x03) out = ( "SUB " + lower );
  if (upper == 0x04) out = ( "STA " + lower );
  if (upper == 0x05) out = ( "LDI " + lower );
  if (upper == 0x06) out = ( "JMP " + lower );
  if (upper == 0x07) out = ( "JC  " + lower );
  if (upper == 0x08) out = ( "JZ  " + lower );
  if (upper == 0x09) out = ( "?09 " + lower );
  if (upper == 0x0a) out = ( "?0A " + lower );
  if (upper == 0x0b) out = ( "?0B " + lower );
  if (upper == 0x0c) out = ( "?0C " + lower );
  if (upper == 0x0d) out = ( "?0D " + lower );
  if (upper == 0x0e) out = ( "OUT " + lower );
  if (upper == 0x0f) out = ( "HLT " + lower );
  return ( out );
}


clock = new ClockModule("Clock", 1);
ucode_ctr = new uCodeCounter("uCodeCounter", 3 );
prog_ctr = new ProgramCounter("ProgramCounter", 4);
mem_addr = new MemoryAddress("MemoryAddress", 4);
mem_data = new MemoryData("MemoryData", 8);
inst_op = new InstructionOperation("InstructionOp", 4);
inst_data = new InstructionData("InstructionData", 4);
a_reg = new ARegister("RegisterA", 8);
b_reg = new BRegister("RegisterB", 8);
sum_reg = new SumRegister("Sum", 8);
carry_bit = new CarryRegister("Carry", 1);
zero_bit = new ZeroRegister("Zero", 1);
display_out = new SevenSegmentDisplay("Display", 3);

var run_mode_LEDs = [ [true,45,111] ];  // Green near Address Register DIP Switch
var program_mode_LEDs = [ [false,55,111] ];  // Red near Address Register DIP Switch

var bus_value_LEDs = [ [false,289,6],
                       [true,298,6],
                       [false,307,6],
                       [true,316,6],
                       [false,325,6],
                       [true,334,6],
                       [false,343,6],
                       [true,352,6] ];

var control_word_LEDs = [ [true,366,497],
                          [false,376,497],
                          [false,385,497],
                          [true,394,497],
                          [false,403,497],
                          [true,412,497],
                          [false,421,497],
                          [true,430,497],
                          [false,439,497],
                          [true,448,497],
                          [false,457,497],
                          [true,466,497],
                          [false,475,497],
                          [true,484,497],
                          [false,493,497],
                          [true,502,497] ];

function randomize_register_bits ( reg ) {
  for (let i=0; i<reg.length; i++) {
    if (Math.random() > 0.5) {
      reg[i][0] = 1;
    } else {
      reg[i][0] = 0;
    }
  }
}

function randomize_all_bits () {
  randomize_register_bits ( control_word_LEDs );
  // randomize_register_bits ( mem_contents_LEDs );
  // randomize_register_bits ( instr_low_LEDs );
  // randomize_register_bits ( instr_high_LEDs );
  // randomize_register_bits ( zero_flag_LEDs );
  // randomize_register_bits ( carry_flag_LEDs );
  // randomize_register_bits ( sum_register_LEDs );
  // randomize_register_bits ( register_B_LEDs );
  // randomize_register_bits ( register_A_LEDs );
  // randomize_register_bits ( mem_address_LEDs );
  randomize_register_bits ( bus_value_LEDs );
  // randomize_register_bits ( ucode_state_LEDs );
  // randomize_register_bits ( ucode_ctr_LEDs );
  // randomize_register_bits ( program_ctr_LEDs );
}


var image = new Image();
var image_loaded = false;

function update_canvas() {
  // console.log ( "Inside Update Canvas" );
  display_status();
  var canvas = document.getElementById('drawing_area');
  // if (consoleDebug) console.log ( "update_canvas" );
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;
    if (image_loaded) {
      // Draw the background image
      ctxt.drawImage(image,0,0);

      // Draw the modules
      // console.log ( "About to draw clock" );
      clock.draw(ctxt);
      ucode_ctr.draw(ctxt);

      // Draw the run mode light
      for (let i=0; i<run_mode_LEDs.length; i++) {
        if (run_mode_LEDs[i][0]) {
          ctxt.fillStyle = green_on;
        } else {
          ctxt.fillStyle = green_off;
        }
        ctxt.beginPath();
        ctxt.arc(run_mode_LEDs[i][1], run_mode_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }
      // Draw the program mode light
      for (let i=0; i<program_mode_LEDs.length; i++) {
        if (program_mode_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(program_mode_LEDs[i][1], program_mode_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Program Counter
      prog_ctr.draw ( ctxt );

      // Draw the Bus lights
      for (let i=0; i<bus_value_LEDs.length; i++) {
        if (bus_value_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(bus_value_LEDs[i][1], bus_value_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      mem_addr.draw ( ctxt );
      mem_data.draw ( ctxt );

      a_reg.draw ( ctxt );

      b_reg.draw ( ctxt );

      sum_reg.draw ( ctxt );

      carry_bit.draw ( ctxt );
      zero_bit.draw ( ctxt );

      inst_op.draw ( ctxt );
      inst_data.draw ( ctxt );

      // Draw the Control Word lights
      for (let i=0; i<control_word_LEDs.length; i++) {
        if (control_word_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(control_word_LEDs[i][1], control_word_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the output display
      display_out.draw ( ctxt );
    };
  }
}

function setup_canvas() {
  var canvas = document.getElementById('drawing_area');
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;

    image.onload = function () {
      image_loaded = true;

      // Draw the background image
      ctxt.drawImage(image,0,0);

      update_canvas();
    };
    image.src = 'computer_background_640.png';
  }
}

function draw_canvas() {
  var drawing_area = document.getElementById ( "drawing_area" );
  if (drawing_area != null) {
    var ctxt = drawing_area.getContext("2d");
    var w = drawing_area.width;
    var h = drawing_area.height;

    image.onload = function () {
        ctxt.drawImage(image,5,5);
    };

  }
}

function mouse_up ( event ) {
  clock.mouse_up ( event );
}

function mouse_down ( event ) {
  clock.mouse_down ( event );
}

stopRunning = false;
function mainLoop()
{
  if (mainLoop.bInMainLoop)
    return;

  mainLoop.bInMainLoop = true;
  mainLoop.bStayInLoop = false;    // by default, release main loop

  if (typeof mainLoop.nCounter == "undefined")
    mainLoop.nCounter = 0;

  if (!stopRunning) {
   exec_next();
  }

  ++mainLoop.nCounter;

  mainLoop.bStayInLoop = true;

  if (stopRunning)
  mainLoop.bStayInLoop = false;

  mainLoop.bInMainLoop = false;

  if (mainLoop.bStayInLoop) {
    setTimeout ( "mainLoop()", clock.get_speed_ms() ); // Call mainLoop X ms from now
  }

  return mainLoop.bStayInLoop;
} // mainLoop

running = false;
run_counter = 1;
function run_stop() {
	running = !running;
	if (running) {
		run();
	} else {
		stop();
	}
}
function run() {
	stopRunning = false;
	mainLoop.nCounter = 0;
	mainLoop();
}
function stop() {
	running = false;
	mainLoop.bStayInLoop = false;
	stopRunning = true;
}
function step() {
	if (running == false) {
		exec_next();
	}
}


var count = 0;
function exec_next() {

  // Toggle the clock
  clock.half_tick();

  // Update the ucode counter
  ucode_ctr.update ( clock.get_state() );


  if ( clock.get_state() && (ucode_ctr.get_state() == 3) ) {
    // Execute the current instruction
    let pc = prog_ctr.get_value();
    if (consoleDebug) console.log ( "Execute " + hex2(memory[pc]) + " = " + decode(memory[pc]) );

    mem_addr.set_value ( pc );
    mem_data.set_value ( memory[pc] );
    let lower = memory[pc] & 0x0f;
    let upper = (memory[pc] >> 4) & 0x0f;

    inst_op.set_value ( upper );
    inst_data.set_value ( lower );

    if (upper == 0x00)        { // "NOP " + lower );
    } else if (upper == 0x01) { // "LDA " + lower );
      mem_addr.set_value ( lower );
      mem_data.set_value ( memory[lower] );
      if (consoleDebug) console.log ( "  A = memory[" + lower + "] = " + memory[lower] );
      let value = memory[lower];
      a_reg.set_value ( value );
      sum_reg.set_value ( (a_reg.get_value() + b_reg.get_value()) );
    } else if (upper == 0x02) { // "ADD " + lower );
      mem_addr.set_value ( lower );
      mem_data.set_value ( memory[lower] );
      if (consoleDebug) console.log ( "  B = memory[" + lower + "] = " + memory[lower] );
      let value = memory[lower];
      b_reg.set_value ( value );
      let result = a_reg.get_value() + b_reg.get_value();
      if (result > 0xff) {
        carry_bit.set_value ( 1 );
      } else {
        carry_bit.set_value ( 0 );
      }
      result = result & 0xff;
      sum_reg.set_value ( result );
      a_reg.set_value ( result );
    } else if (upper == 0x03) { // "SUB " + lower );
      mem_addr.set_value ( lower );
      mem_data.set_value ( memory[lower] );
      if (consoleDebug) console.log ( "  B = memory[" + lower + "] = " + memory[lower] );
      let value = memory[lower];
      b_reg.set_value ( value );
      sum_reg.set_value ( a_reg.get_value() - b_reg.get_value() );
      a_reg.set_value ( sum_reg.get_value() );
    } else if (upper == 0x04) { // "STA " + lower );
      mem_addr.set_value ( lower );
      mem_data.set_value ( memory[lower] );
      memory[lower] = a_reg.get_value();
      sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
    } else if (upper == 0x05) { // "LDI " + lower );
      if (consoleDebug) console.log ( "  A = " + lower );
      a_reg.set_value ( lower );
      sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
    } else if (upper == 0x06) { // "JMP " + lower );
      mem_addr.set_value ( lower );
      if (consoleDebug) console.log ( "  JMP " + lower );
      let value = memory[lower];
      mem_data.set_value ( memory[lower] );
      pc = lower - 1; // Jump before destination since pc will be incremented
    } else if (upper == 0x07) { // "JC  " + lower );
      if (carry_bit.get_value() != 0) {
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        let value = memory[lower];
        pc = lower - 1; // Jump before destination since pc will be incremented
      }
    } else if (upper == 0x08) { // "JZ  " + lower );
    } else if (upper == 0x09) { // "?09 " + lower );
    } else if (upper == 0x0a) { // "?0A " + lower );
    } else if (upper == 0x0b) { // "?0B " + lower );
    } else if (upper == 0x0c) { // "?0C " + lower );
    } else if (upper == 0x0d) { // "?0D " + lower );
    } else if (upper == 0x0e) { // "OUT " + lower );
      // output_display
      console.log ( "Out = " + a_reg.get_value() );
      display_out.set_digits ( String(a_reg.get_value()) );
    } else if (upper == 0x0f) { // "HLT " + lower );
      stop();
      clock.clock_run_stop_button[0][0] = false;
      stop();
    }

    // Increment the program counter as needed
    pc = (pc + 1) % 16;
    prog_ctr.set_value ( pc );
  }

  // Set all others to random values (used during development)
  randomize_all_bits();
  update_canvas();

	count = count + 1;
}

function cpu_reset() {
	is_idle = false;
	running = true;
	stopRunning = true;
	run_stop();
	stop();
	run_counter = 1;
	mainLoop.nCounter = 0;
	ucode_ctr.reset();
}

window.onload = setup_canvas;

setup_canvas();

</script>

</head>

<body id='page' onload="setup_canvas()" onresize="update_canvas()" bgcolor="lightblue">

<table>
<tr><td>
<canvas id="drawing_area" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)"></canvas>
</td>
<td id="status_area">

<select id="examples" onchange="change_example()">
<option value="Examples">Examples</option>
<option value="No Ops">No Ops</option>
<option value="Counter">Counter</option>
<option value="Fibonacci">Fibonacci</option>
</select>

<pre id="next_instruction">Next goes here.
</pre>
<p></p>
<pre id="mem_status">Memory goes here.
</pre>
<p></p>
<input type="checkbox" id="debug" checked onclick="toggle_debug();">Debug</input>
</td></tr>
</table>

</body>
