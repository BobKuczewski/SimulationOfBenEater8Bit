<!DOCTYPE html>

<html>

<head>
<title>Ben Eater's 8-bit Computer Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<script>


var memory = [ // Fibonacci Numbers up to 233
/* 0 */ 0x51,  // ldi 1   ; 1
/* 1 */ 0x4e,  // sta e   ; y(e) = 1
/* 2 */ 0x50,  // ldi 0   ; x = 0
/* 3 */ 0x2e,  // add [e] ; x + y
/* 4 */ 0x4f,  // sta [f] ; z = x + y
/* 5 */ 0x1e,  // lda [e] ; y
/* 6 */ 0x4d,  // sta [d] ; x = y
/* 7 */ 0x1f,  // lda [f] ; z
/* 8 */ 0x4e,  // sta [e] ; y = z
/* 9 */ 0x1d,  // lda [d] ; x
/* a */ 0xe0,  // out
/* b */ 0x70,  // jc  0   ; jump carry to next Fib
/* c */ 0x63,  // jmp 3   ; keep adding
/* d */ 0x00,  // x
/* e */ 0x00,  // y
/* f */ 0x00,  // z
];


function hex1 ( v ) {
	return ( (v % 16).toString(16).toUpperCase() );
}

function hex2 ( v ) {
	h = (v % 256).toString(16).toUpperCase();
	while (h.length < 2) {
		h = "0" + h;
	}
	return ( h );
}

function hex4 ( v ) {
	h = (v % 65536).toString(16).toUpperCase();
	while (h.length < 4) {
		h = "0" + h;
	}
	return ( h );
}

function display_status() {
  let txt = "";
  let next_instr = document.getElementById('next_instruction');
  let npc = prog_ctr.get_value();
  let no = memory[npc];
  txt = " Next:\n  " + hex1(npc) + ":" + hex2(no) + " " + decode(no) + "\n";
  next_instr.innerHTML = txt;

  let mem_disp = document.getElementById('mem_status');
  txt = " Memory:\n";
  for (let i=0; i<memory.length; i++) {
    let p = "";
    // if (i == npc) {
    if (i == ucode_ctr.last_pc) {
      p = " <<---";
    }
    txt = txt + "  " + hex1(i) + " " + hex2(memory[i]) + p + "\n";
  }
  mem_disp.innerHTML = txt;
}

function single_spaces ( s ) {
  let ss = s.trim();
  while (ss.indexOf('  ') >= 0) {
    ss = ss.replaceAll('  ',' ');
  }
  return ( ss );
}


function load_hex() {
  let hex = document.getElementById("Hex Code").value;
  hex = single_spaces ( hex );
  if (hex.length > 0) {
    let hex_list = hex.trim().replaceAll('\n',' ').replace('  ',' ').split(' ');
    for (let i=0; i<hex_list.length; i++) {
      hex_list[i] = parseInt ( hex_list[i], 16 );
    }
    memory = hex_list;
    while (memory.length < 16) {
      memory.push(0);
    }
  }
  update_canvas();
}

function zero_hex() {
  let hex_code = "00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n";
  document.getElementById("Hex Code").value = hex_code;
  update_canvas();
}


function assemble() {
  let asm = document.getElementById("Source Code").value;
  let asm_list = asm.trim().replaceAll('\r','\n').split('\n');
  let instr_list = [];
  // Remove empty lines
  for (let i=0; i<asm_list.length; i++) {
    if (asm_list[i].trim().length > 0) {
      instr_list.push ( asm_list[i].trim() );
    }
  }
  // Condense any multiple spaces down to a single space
  for (let i=0; i<instr_list.length; i++) {
    instr_list[i] = single_spaces ( instr_list[i] );
  }
  // Begin generating the hex code
  let hex_code = "";
  for (let i=0; i<instr_list.length; i++) {
    // Encode the instruction into an integer
    let opcode = encode ( instr_list[i] );
    // Convert the integer into a 2 digit hex value
    if (opcode >= 0) {
      hex_code = hex_code + hex2(opcode) + "\n";
    }
  }
  document.getElementById("Hex Code").value = hex_code;
}

function change_example() {
  if (document.getElementById("examples").value == "Examples") {
    document.getElementById("Source Code").value = "";
  } else if (document.getElementById("examples").value == "NOP HLT") {
    document.getElementById("Source Code").value = "0 NOP\n1 HLT\n";
  } else if (document.getElementById("examples").value == "Line Nums") {
    document.getElementById("Source Code").value =
      "0 \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \nA \nB \nC \nD \nE \nF \n";
  } else if (document.getElementById("examples").value == "Counter") {
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 STA F\n2 LDI 0\n3 ADD F\n4 OUT\n5 JMP 3\n";
  } else if (document.getElementById("examples").value == "Fibonacci") {
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 STA E\n2 LDI 0\n3 ADD E\n4 STA F\n5 LDA E\n6 STA D\n7 LDA F\n" +
      "8 STA E\n9 LDA D\nA OUT\nB JC 0\nC JMP 3\nD 0\nE 0\nF 0\n";
  } else if (document.getElementById("examples").value == "CountUpDown") {
    document.getElementById("Source Code").value =
      "0 out\n1 add f\n2 jc 4\n3 jmp 0\n4 sub f\n5 out\n6 jz 0\n7 jmp 4\n" +
      "8 0\n9 0\na 0\nb 0\nc 0\nd 0\ne 0\nf 5\n";
  } else if (document.getElementById("examples").value == "Add 14+28") {
    document.getElementById("Source Code").value =
      "0 lda 4\n1 add 5\n2 out\n3 hlt\n4 0e\n5 1c\n6 0\n7 0\n" +
      "8 0\n9 0\na 0\nb 0\nc 0\nd 0\ne 0\nf 1\n";
  } else if (document.getElementById("examples").value == "Mult 3x5") {
    document.getElementById("Source Code").value =
      "0 lda e\n1 sub c\n2 jc 6\n3 lda d\n4 out\n5 hlt\n6 sta e\n7 lda d\n" +
      "8 add f\n9 sta d\na jmp 0\nb 0\nc 1\nd 0\ne 3\nf 5\n";
  } else if (document.getElementById("examples").value == "Mult 7x8") {
    document.getElementById("Source Code").value =
      "0 LDA E\n1 SUB C\n2 JC 6\n3 LDA D\n4 OUT\n5 HLT\n6 STA E\n7 LDA D\n" +
      "8 ADD F\n9 STA D\nA JMP 0\nB 0\nC 1\nD 0\nE 7\nF 8\n"
  } else if (document.getElementById("examples").value == "Mult 15x15") {
    document.getElementById("Source Code").value =
      "0 LDA E\n1 SUB C\n2 JC 6\n3 LDA D\n4 OUT\n5 HLT\n6 STA E\n7 LDA D\n" +
      "8 ADD F\n9 STA D\nA JMP 0\nB 0\nC 1\nD 0\nE F\nF F\n"
  }
  display_status();
  update_canvas();
}


var gray_on = "#cccccc";
var gray_off = "#444444";
var red_on = "#ff6060";
var red_off = "#880000";
var yellow_on = "#ffff00";
var yellow_off = "#705010";
var blue_on = "#bbccff";
var blue_off = "#304090";
var green_on = "#80ff08";
var green_off = "#185621";

class Register {
  constructor ( name, nbits ) {
    this.nbits = nbits;
    this.reg_name = name;
    this.on_color = gray_on;
    this.off_color = gray_off;
    this.radius = 10;
    this.state = [ true ];
    this.position = [ [20,90] ];
  }
  get_state() {
    return ( this.state );
  }
  get_value() {
    let value = 0;
    let n = this.state.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      if (this.state[i]) {
        value = value | (0x01 << bit);
      }
      bit = bit - 1;
    }
    value = value & ((2**this.nbits)-1);
    return ( value );
  }
  set_value ( value ) {
    // The register indexes are bit positions, so reverse
    // value = 1101  gives [ 1, 0, 1, 1 ]
    value = value & ( (2 ** this.nbits) - 1 ); // Mask off any higher order bits
    this.state = [];
    let n = this.position.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      // if ((value >> bit) & 0x01) > 0) {
      if ((value & (0x01 << bit)) > 0) {
        this.state.push ( true );
      } else {
        this.state.push ( false );
      }
      bit = bit - 1;
    }
  }
  randomize_bits () {
    for (let i=0; i<this.state.length; i++) {
      if (Math.random() > 0.5) {
        this.state[i] = true;
      } else {
        this.state[i] = false;
      }
    }
  }
  draw ( ctxt ) {
    // Draw the Register lights
    for (let i=0; i<this.position.length; i++) {
      let s = false;
      if (i < this.state.length) {
        s = this.state[i];
      }
      if (s) {
        ctxt.fillStyle = this.on_color;
      } else {
        ctxt.fillStyle = this.off_color;
      }
      ctxt.beginPath();
      ctxt.arc(this.position[i][0], this.position[i][1], this.radius, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }
  toString() {
    let s = "Register " + this.reg_name + " = " + this.get_value();
    return ( s );
  }
}


class Button {
  constructor ( name, center_x, center_y, w, h ) {
    this.button_name = name;
    this.down_color = "#ffcccc80";
    this.up_color   = "#ccccff80";
    this.down = false;
    this.center_x = center_x;
    this.center_y = center_y;
    this.width = w;
    this.height = h;
    this.corner_x = this.center_x - (this.width/2);
    this.corner_y = this.center_y - (this.height/2);
  }
  get_corrected_coords ( event ) {
    // This function is needed on browsers where offsetX and offsetY are not correct.
    let offsets = [];
    let target = event.target || event.srcElement;
    let rect = target.getBoundingClientRect();
    let offsetX = event.clientX - rect.left;
    let offsetY = event.clientY - rect.top;
    let corrected = [offsetX, offsetY];
    return corrected;
  }
  set_down() {
    this.down = true;
  }
  set_up() {
    this.down = false;
  }
  set_down_color ( color ) {
    this.down_color = color;
  }
  set_up_color ( color ) {
    this.up_color = color;
  }
  draw(ctxt) {
    if (this.down) {
      ctxt.fillStyle = this.down_color;
    } else {
      ctxt.fillStyle = this.up_color;
    }
    ctxt.fillRect( this.corner_x, this.corner_y, this.width, this.height );
  }
  event_in_button ( event ) {
    let coords = this.get_corrected_coords ( event );
    if ( (coords[0] >= this.corner_x) && (coords[0] <= (this.corner_x + this.width)) ) {
      if ( (coords[1] >= this.corner_y) && (coords[1] <= (this.corner_y + this.height)) ) {
        return ( true );
      }
    }
    return ( false );
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = true;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
    if (this.event_in_button(event)) {
      this.down = false;
      update_canvas();
      this.up_action ( event );
    }
  }
  down_action ( event ) {
    // Implement in subclasses
  }
  up_action ( event ) {
    // Implement in subclasses
  }
}

class ToggleButton extends Button {
  constructor ( name, center_x, center_y, w, h ) {
    super ( name, center_x, center_y, w, h );
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = !this.down;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
  }
}


class DIPSwitch extends ToggleButton {
  constructor ( name, center_x, center_y, w, h ) {
    super ( name, center_x, center_y, w, h );
    this.down_color = "#ffffff";
    this.up_color   = "#000000";
  }
  get_value() {
    if (this.down) {
      return ( 1 );
    } else {
      return ( 0 );
    }
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = !this.down;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
  }
}


var button_list = [];

function draw_button_list ( ctxt ) {
  for (let i=0; i<button_list.length; i++) {
    button_list[i].draw(ctxt);
  }
}

function execute_button_list_down ( event ) {
  // NOTE: The clientX and clientY from the event may need correction.
  // This is handled in the button class, but not in the event itself.
  for (let i=0; i<button_list.length; i++) {
    button_list[i].mouse_down(event);
  }
}

function execute_button_list_up ( event ) {
  // NOTE: The clientX and clientY from the event may need correction.
  // This is handled in the button class, but not in the event itself.
  for (let i=0; i<button_list.length; i++) {
    button_list[i].mouse_up(event);
  }
}

class ClockStepButton extends Button { // clock_step
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    step();
    update_canvas();
  }
  up_action ( event ) {
    step();
    update_canvas();
  }
}

class ClockRunStopButton extends ToggleButton { // clock_run_stop_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    clock.mouse_down(event);
  }
  up_action ( event ) {
    clock.mouse_up(event);
  }
}

class ResetButton extends Button { // reset_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  reset() {
    cpu_reset();
    this.state = false;
    clock.set_value(false);
    ucode_ctr.set_value(0);
    ucode_ctr.last_pc = 0;
    prog_ctr.set_value(0);
    mem_addr.set_value(0);
    mem_data.set_value(0);
    inst_op.set_value(0);
    inst_data.set_value(0);
    a_reg.set_value(0);
    b_reg.set_value(0);
    sum_reg.set_value(0);
    carry_bit.set_value(0);
    zero_bit.set_value(0);
    display_out.set_value(0);
    bus.set_value(0);
    display_out.set_digits ("0");
    clock.clock_run_stop_button.down = false;
    update_canvas();
  }
  down_action ( event ) {
    this.reset();
  }
  up_action ( event ) {
  }
}


class SpeedButton extends Button { // clock_speed_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    if (this.clock.clock_speed_index < this.clock.clock_speeds.length-1) {
      this.clock.clock_speed_index += 1;
    } else {
      this.clock.clock_speed_index = 0;
    }
    this.down_color = this.clock.clock_speed_colors[this.clock.clock_speed_index];
    this.up_color = this.clock.clock_speed_colors[this.clock.clock_speed_index];
    update_canvas();
  }
  up_action ( event ) {
  }
}


class ClockModule { // extends Register {

  constructor (name,nbits) {
    // super(name,nbits);
    this.clock_speeds       = [ 1000,        100,         10,          1          ]; // Actually clock intervals in milliseconds
    this.clock_speed_colors = [ "#0000ff44", "#00ff0044", "#dddd0044", "#ff000044"];
    this.clock_speed_index = this.clock_speeds.length-1;

    this.clock_run_stop_button = new ClockRunStopButton ( "Clock Run/Stop", 121,29, 20,20, this );
    button_list.push ( this.clock_run_stop_button );

    this.clock_step_button = new ClockStepButton ( "Clock Step", 71,34, 20,20, this );
    button_list.push ( this.clock_step_button );

    this.reset_button = new ResetButton ( "Reset", 32,343, 20,20, this );
    button_list.push ( this.reset_button );

    this.speed_button = new SpeedButton ( "Clock Speed", 19,10, 20,20, this );
    this.speed_button.up_color   = this.clock_speed_colors[this.clock_speed_index];
    this.speed_button.down_color = this.clock_speed_colors[this.clock_speed_index];
    button_list.push ( this.speed_button );

    this.nbits = nbits;
    this.reg_name = name;
    this.state = false;
    this.reset();
  }

  run() {
    this.clock_run_stop_button.down = true;
    this.state = true;
    run();
  }

  stop() {
    stop();
    this.clock_run_stop_button.down = false;
    this.state = false;
  }

  reset() {
    this.state = false;
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.position = [ 232, 6 ];
    this.radius = 5;
  }

  half_tick() {
    this.state = ! this.state;
  }

  get_state() {
    return ( this.state );
  }

  set_value( v ) {
    this.state = v;
  }

  get_speed_ms() {
    return ( this.clock_speeds[this.clock_speed_index] );
  }

  mouse_up ( event ) {
  }

  mouse_down ( event ) {
    if (this.clock_run_stop_button.down) {
      run();
    } else {
      stop();
    }
    update_canvas();
  }

  draw(ctxt) {
    // Draw the Clock LED
    if (this.state) {
      ctxt.fillStyle = blue_on;
    } else {
      ctxt.fillStyle = blue_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0], this.position[1], 5, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class uCodeCounter extends Register {

  constructor (name,nbits) {
    super("uCodeCounter",nbits);
    this.state = 0;
    this.ucode_ctr_LEDs = [ [false,33,395],[false,43,395],[false,53,395] ];
    this.ucode_state_LEDs = [ [false,66,390],
                              [true,76,390],
                              [true,86,390],
                              [true,97,390],
                              [true,108,390],
                              [true,120,390] ];
    this.last_pc = 0;
  }

  get_value() {
    return ( this.state );
  }
  reset() {
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      this.ucode_ctr_LEDs[i][0] = false;
    }
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      this.ucode_state_LEDs[i][0] = true;
    }
    this.ucode_state_LEDs[0][0] = false;
  }

  update ( clock_state ) {
    // Update the ucode counter on the appropriate clock edge
    if (!clock_state) {
      this.ucode_ctr_LEDs[0][0] = !this.ucode_ctr_LEDs[0][0];
      if (!this.ucode_ctr_LEDs[0][0]) {
        this.ucode_ctr_LEDs[1][0] = !this.ucode_ctr_LEDs[1][0];
        if (!this.ucode_ctr_LEDs[1][0]) {
          this.ucode_ctr_LEDs[2][0] = !this.ucode_ctr_LEDs[2][0];
        }
      }
    }

    // Update the ucode state based on the counter
    this.state = 0;
    if (this.ucode_ctr_LEDs[2][0]) {
      this.state = this.state | 0x04;
    }
    if (this.ucode_ctr_LEDs[1][0]) {
      this.state = this.state | 0x02;
    }
    if (this.ucode_ctr_LEDs[0][0]) {
      this.state = this.state | 0x01;
    }
    if (this.state > 5) {
      this.state = 0;
      this.ucode_ctr_LEDs[0][0] = false;
      this.ucode_ctr_LEDs[1][0] = false;
      this.ucode_ctr_LEDs[2][0] = false;
    }
    this.ucode_state_LEDs[0][0] = true;
    this.ucode_state_LEDs[1][0] = true;
    this.ucode_state_LEDs[2][0] = true;
    this.ucode_state_LEDs[3][0] = true;
    this.ucode_state_LEDs[4][0] = true;
    this.ucode_state_LEDs[5][0] = true;
    this.ucode_state_LEDs[this.state][0] = false;

    if (this.state == 0) {
      // Store the last PC (mostly used for display)
      this.last_pc = prog_ctr.get_value();
    }

    return ( this.state );
  }

  draw_ucode_ctr ( ctxt ) {
    // Draw the Microcode Counter
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      if (this.ucode_ctr_LEDs[i][0]) {
        ctxt.fillStyle = red_on;
      } else {
        ctxt.fillStyle = red_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_ctr_LEDs[i][1], this.ucode_ctr_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw_ucode_state ( ctxt ) {
    // Draw the Microcode State
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      if (this.ucode_state_LEDs[i][0]) {
        ctxt.fillStyle = green_on;
      } else {
        ctxt.fillStyle = green_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_state_LEDs[i][1], this.ucode_state_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw(ctxt) {
    this.draw_ucode_ctr ( ctxt );
    this.draw_ucode_state ( ctxt );
  }
}


class ARegister extends Register {
  constructor (name,nbits) {
    super("A Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [ true, false, true, false, false, false, true, true ];
    this.position = [ [422,134],[432,134],[443,134],[453,134],[464,134],[474,134],[485,134],[495,134] ];
  }
}


class BRegister extends Register {
  constructor (name,nbits) {
    super("B Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [424,290],[434,290],[445,290],[455,290],[466,290],[477,290],[488,290],[498,290] ];
  }
}


class SumRegister extends Register {
  constructor (name,nbits) {
    super("Sum Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [368,220],[377,221],[389,221],[400,222],[409,222],[419,222],[429,222],[441,222] ];
  }
}

class CarryRegister extends Register {
  constructor (name,nbits) {
    super("Carry Bit",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [562,133] ];
  }
}

class ZeroRegister extends Register {
  constructor (name,nbits) {
    super("Zero Bit",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [572,133] ];
  }
}

class RunProgMode extends Register {
  constructor (name,nbits) {
    super("Run Mode",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [true,false];
    this.position = [ [45,111], [55,111] ];
  }
  set_value ( value ) {
    // Value will only specify one bit
    if (value == 0) {
      this.state = [false,true]
    } else {
      this.state = [true,false]
    }
  }
  draw ( ctxt ) {
    // First draw the "Run" LED
    if (this.state[0]) {
      ctxt.fillStyle = this.on_color;
    } else {
      ctxt.fillStyle = this.off_color;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0][0], this.position[0][1], this.radius, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
    // Next draw the "Program" LED (always opposite of "Run")
    if (!this.state[0]) {
      ctxt.fillStyle = red_on;
    } else {
      ctxt.fillStyle = red_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[1][0], this.position[1][1], this.radius, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class ProgModeToggle extends ToggleButton { // prog_mode_toggle
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
  }
  down_action ( event ) {
    run_prog_mode.set_value ( !this.down );
    update_canvas();
  }
  up_action ( event ) {
    run_prog_mode.set_value ( !this.down );
    update_canvas();
  }
}

class ProgramWrite extends Button { // program_write_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
  }
  down_action ( event ) {
    if (prog_mode_toggle.down) {
      let mem_addr = (mem_addr_DIP_3.get_value() << 3) +
                     (mem_addr_DIP_2.get_value() << 2) +
                     (mem_addr_DIP_1.get_value() << 1) +
                     (mem_addr_DIP_0.get_value() << 0);
      let data_val = (data_in_DIP_7.get_value() << 7) +
                     (data_in_DIP_6.get_value() << 6) +
                     (data_in_DIP_5.get_value() << 5) +
                     (data_in_DIP_4.get_value() << 4) +
                     (data_in_DIP_3.get_value() << 3) +
                     (data_in_DIP_2.get_value() << 2) +
                     (data_in_DIP_1.get_value() << 1) +
                     (data_in_DIP_0.get_value() << 0);
      if (mem_addr < memory.length) {
        memory[mem_addr] = data_val;
      }
    } else {
      console.log ( "Unable to Program in Run Mode - Toggle the Run/Load Button" );
    }
  }
}


class ProgramCounter extends Register {
  constructor (name,nbits) {
    super("Program Counter",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [386,6], [395,6], [404,6], [413,6] ];
  }
}


class InstructionOperation extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [true,false,false,false];
    this.position = [ [148,369], [157,370], [166,371], [177,371] ];
  }
}
class InstructionData extends Register {
  constructor (name,nbits) {
    super("Instruction Data",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,true];
    this.position = [ [187,371], [197,371], [207,371], [217,371] ];
  }
}


class MemoryAddress extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [147,145], [157,146], [166,145], [176,146] ];
  }
}

class MemoryData extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false];
    this.position = [ [138,225], [147,225], [156,225], [166,225], [176,225], [187,225], [198,225], [208,225] ];
  }
}

class BusContents extends Register {
  constructor (name,nbits) {
    super("BusContents",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false];
    this.position = [ [289,6], [298,6], [307,6], [316,6], [325,6], [334,6], [343,6], [352,6] ];
  }
}

class ControlWord extends Register {
  constructor (name,nbits) {
    super("ControlWord",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false];
    this.position = [ [366,497], [376,497], [385,497], [394,497], [403,497], [412,497], [421,497], [430,497],
                      [439,497], [448,497], [457,497], [466,497], [475,497], [484,497], [493,497], [502,497] ];
  }
}


class SevenSegmentDisplay extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.digits = "0";
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [true,true,true,true,true,true,true];
    let off = 35;
    this.position = [ [565+off,333], [578+off,332], [576+off,343], [574+off,355], [561+off,355], [563+off,343] ];
    this.segments = [ [0,1], [1,2], [2,3], [3,4], [4,5], [5,0], [2,5] ];
    this.digit_segments = [
      /* 0 */ [0,1,2,3,4,5],
      /* 1 */ [1,2],
      /* 2 */ [0,1,6,4,3],
      /* 3 */ [0,1,2,3,6],
      /* 4 */ [1,2,5,6],
      /* 5 */ [0,2,3,5,6],
      /* 6 */ [0,2,3,4,5,6],
      /* 7 */ [0,1,2],
      /* 8 */ [0,1,2,3,4,5,6],
      /* 9 */ [0,1,2,3,5,6],
    ];
  }

  set_digits ( digits ) {
    this.digits = digits;
  }

  draw_digit ( ctxt, d, offset ) {
    let segs = this.digit_segments[d];
    ctxt.strokeStyle = "#fd4a57";
    ctxt.lineWidth = 3;
    for (let i=0; i<segs.length; i++) {
      let seg = this.segments[segs[i]]
      let start = this.position[seg[0]];
      let end   = this.position[seg[1]];
      ctxt.beginPath();
      ctxt.moveTo(offset+start[0], start[1]);
      ctxt.lineTo(offset+end[0], end[1]);
      ctxt.stroke();
    }
  }

  draw(ctxt) {
    if (this.digits.length > 0) {
      for (let i=0; i<this.digits.length; i++) {
        let shft = this.digits.length - (i+1);
        let offset = -22 * shft;
        this.draw_digit ( ctxt, this.digits[i], offset );
      }
    }
  }
}


function decode ( instruction ) {
  let out = "";
  let lower = instruction & 0x0f;
  let upper = (instruction >> 4) & 0x0f;
  if (upper == 0x00) out = ( "NOP " + lower );
  if (upper == 0x01) out = ( "LDA " + lower );
  if (upper == 0x02) out = ( "ADD " + lower );
  if (upper == 0x03) out = ( "SUB " + lower );
  if (upper == 0x04) out = ( "STA " + lower );
  if (upper == 0x05) out = ( "LDI " + lower );
  if (upper == 0x06) out = ( "JMP " + lower );
  if (upper == 0x07) out = ( "JC  " + lower );
  if (upper == 0x08) out = ( "JZ  " + lower );
  if (upper == 0x09) out = ( "?09 " + lower );
  if (upper == 0x0a) out = ( "?0A " + lower );
  if (upper == 0x0b) out = ( "?0B " + lower );
  if (upper == 0x0c) out = ( "?0C " + lower );
  if (upper == 0x0d) out = ( "?0D " + lower );
  if (upper == 0x0e) out = ( "OUT " + lower );
  if (upper == 0x0f) out = ( "HLT " + lower );
  return ( out );
}

function encode ( instruction ) {
  let digits = '0123456789ABCEDF';
  let inst = single_spaces ( instruction );
  inst = inst.toUpperCase().split(' ');
  if (inst.length >= 2) {
    // Legal since all must be at least 2 (or 3)
    // Check to see if the second operand is an instruction
    let legal   = ["NOP","LDA","ADD","SUB","STA","LDI","JMP","JC","JZ","OUT","HLT"];
    let opcodes = [ 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60,0x70,0x80, 0xE0,0xf0 ];
    let index = legal.indexOf(inst[1]);
    if (index >= 0) {
      // This is an op code with an optional parameter
      let opcode = opcodes[index];
      if (inst.length > 2) {
        // Append the parameter
        opcode = opcode | parseInt ( inst[2], 16 );
      }
      return ( opcode );
    } else {
      // This must be a stored number
      if (digits.search(inst[1][0]) >= 0) {
        // This is a number
        return ( parseInt ( inst[1], 16 ) );
      } else {
        return ( -1 );
      }
    }
  }
  return ( -1 ); // Indicates an error
}


clock = new ClockModule("Clock", 1);
run_prog_mode = new RunProgMode ("Run Mode", 2);
ucode_ctr = new uCodeCounter("uCode Counter", 3 );
prog_ctr = new ProgramCounter("Program Counter", 4);
mem_addr = new MemoryAddress("Memory Address", 4);
mem_data = new MemoryData("Memory Data", 8);
inst_op = new InstructionOperation("Instruction Op", 4);
inst_data = new InstructionData("Instruction Data", 4);
a_reg = new ARegister("Register A", 8);
b_reg = new BRegister("Register B", 8);
sum_reg = new SumRegister("Sum", 8);
carry_bit = new CarryRegister("Carry", 1);
zero_bit = new ZeroRegister("Zero", 1);
bus = new BusContents("Bus", 8);
control_word = new ControlWord("Control", 16);
display_out = new SevenSegmentDisplay("Display", 3);

prog_mode_toggle = new ProgModeToggle ( "Program Toggle", 32,108, 14,14, null );
button_list.push ( prog_mode_toggle );

program_write_button = new ProgramWrite ( "Program Write", 25,267, 20,20, null );
button_list.push ( program_write_button );

mem_addr_DIP_3 = new DIPSwitch ( "DIP_MA3", 70,111, 3,7, null );
button_list.push ( mem_addr_DIP_3 );
mem_addr_DIP_2 = new DIPSwitch ( "DIP_MA2", 74,111, 3,7, null );
button_list.push ( mem_addr_DIP_2 );
mem_addr_DIP_1 = new DIPSwitch ( "DIP_MA1", 79,111, 3,7, null );
button_list.push ( mem_addr_DIP_1 );
mem_addr_DIP_0 = new DIPSwitch ( "DIP_MA0", 83,111, 3,7, null );
button_list.push ( mem_addr_DIP_0 );

data_in_DIP_7 = new DIPSwitch ( "DIP_D7", 79,268, 3,7, null );
button_list.push ( data_in_DIP_7 );
data_in_DIP_6 = new DIPSwitch ( "DIP_D6", 83,268, 3,7, null );
button_list.push ( data_in_DIP_6 );
data_in_DIP_5 = new DIPSwitch ( "DIP_D5", 87,268, 3,7, null );
button_list.push ( data_in_DIP_5 );
data_in_DIP_4 = new DIPSwitch ( "DIP_D4", 91,268, 3,7, null );
button_list.push ( data_in_DIP_4 );
data_in_DIP_3 = new DIPSwitch ( "DIP_D3", 97,268, 3,7, null );
button_list.push ( data_in_DIP_3 );
data_in_DIP_2 = new DIPSwitch ( "DIP_D2", 101,268, 3,7, null );
button_list.push ( data_in_DIP_2 );
data_in_DIP_1 = new DIPSwitch ( "DIP_D1", 105,268, 3,7, null );
button_list.push ( data_in_DIP_1 );
data_in_DIP_0 = new DIPSwitch ( "DIP_D0", 109,268, 3,7, null );
button_list.push ( data_in_DIP_0 );

// This allows toggling between microcode and macrocode.
// However, the macrocode is not currently being maintained.
micromacro = new ToggleButton ("MicroMacro", 600, 30, 20, 20);
micromacro.up_color   = "#ff888840";
micromacro.down_color = "#ff5555e0";
button_list.push ( micromacro );

var image = new Image();
var image_loaded = false;

function update_canvas() {
  display_status();
  var canvas = document.getElementById('drawing_area');
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;

    if (image_loaded) {

      // Draw the background image
      ctxt.drawImage(image,0,0);

      // Draw the modules

      // Draw the clock
      clock.draw(ctxt);

      // Draw the micro-code counter
      ucode_ctr.draw(ctxt);

      // Draw the program mode light
      run_prog_mode.draw ( ctxt );

      // Draw the Program Counter register
      prog_ctr.draw ( ctxt );

      // Draw the Bus lights
      bus.draw ( ctxt );

      // Draw the memory address and memory data registers
      mem_addr.draw ( ctxt );
      mem_data.draw ( ctxt );

      // Draw the A, B, and Sum registers
      a_reg.draw ( ctxt );
      b_reg.draw ( ctxt );
      sum_reg.draw ( ctxt );

      // Draw the flags (carry and zero)
      carry_bit.draw ( ctxt );
      zero_bit.draw ( ctxt );

      // Draw the instruction operation and data registers
      inst_op.draw ( ctxt );
      inst_data.draw ( ctxt );

      // Draw the Control Word lights
      control_word.draw ( ctxt );

      // Draw the output display
      display_out.draw ( ctxt );

      // Draw the buttons on top of everything else
      draw_button_list ( ctxt );

    }
  }
}

function setup_canvas() {
  var canvas = document.getElementById('drawing_area');
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 480;

    image.onload = function () {
      image_loaded = true;

      // Draw the background image
      ctxt.drawImage(image,0,0);

      update_canvas();
    };

    image.src = 'computer_background_640.png';
  }
}

function draw_canvas() {
  var drawing_area = document.getElementById ( "drawing_area" );
  if (drawing_area != null) {
    var ctxt = drawing_area.getContext("2d");
    var w = drawing_area.width;
    var h = drawing_area.height;

    image.onload = function () {
        ctxt.drawImage(image,5,5);
    };
  }
}

function mouse_up ( event ) {
  // clock.mouse_up ( event );
  execute_button_list_up ( event );
}

function mouse_down ( event ) {
  // clock.mouse_down ( event );
  execute_button_list_down ( event );
}

stop_running = false;
function main_loop()
{
  if (main_loop.in_main_loop)
    return;

  main_loop.in_main_loop = true;
  main_loop.bStayInLoop = false;    // by default, release main loop

  if (typeof main_loop.main_loop_counter == "undefined")
    main_loop.main_loop_counter = 0;

  if (!stop_running) {
    if (clock.clock_speeds == 0) {
      // Execute multiple instructions for extra speed
      for (let i=0; i<5; i++) {
        exec_next();
      }
    } else {
      exec_next();
    }
  }

  main_loop.main_loop_counter += 1;

  main_loop.bStayInLoop = true;

  if (stop_running)
  main_loop.bStayInLoop = false;

  main_loop.in_main_loop = false;

  if (main_loop.bStayInLoop) {
    setTimeout ( "main_loop()", clock.get_speed_ms() ); // Call main_loop X ms from now
  }

  return main_loop.bStayInLoop;
} // main_loop

running = false;
run_counter = 1;
function run_stop() {
	running = !running;
	if (running) {
		run();
	} else {
		stop();
	}
}
function run() {
	stop_running = false;
	main_loop.main_loop_counter = 0;
	main_loop();
}
function stop() {
	running = false;
	main_loop.bStayInLoop = false;
	stop_running = true;
}
function step() {
	if (running == false) {
		exec_next();
	}
}

const HT = 0b1000000000000000; // Halt
const MI = 0b0100000000000000; // Memory Address Register In
const RI = 0b0010000000000000; // RAM In
const RO = 0b0001000000000000; // RAM Out
const IO = 0b0000100000000000; // Instruction Register Out
const II = 0b0000010000000000; // Instruction Register In
const AI = 0b0000001000000000; // A Register In
const AO = 0b0000000100000000; // A Register Out
const EO = 0b0000000010000000; // Sum Out (E looks like sigma)
const SU = 0b0000000001000000; // Subtract Signal
const BI = 0b0000000000100000; // B Register In
const OI = 0b0000000000010000; // Output Register In
const CE = 0b0000000000001000; // Program Counter Enabled
const CO = 0b0000000000000100; // Program Counter Out
const J  = 0b0000000000000010; // Jump
const FI = 0b0000000000000001; // Flags In???

const micro_bit_names = ['HT','MI','RI','RO','IO','II','AI','AO','EO','SU','BI','OI','CE','CO','J'];


function console_log ( s ) {
  // console.log ( s );
}

var count = 0;
function exec_next() {

  // Toggle the clock
  clock.half_tick();

  if (! micromacro.down) {
    // Execucte micro instructions step by step
    console_log ( "Micro" );
    ucode_ctr.update ( clock.get_state() );
    if (clock.get_state()) {
      let ucode_step = ucode_ctr.get_value();
      console_log ( "ucode step: " + ucode_step );
      if (ucode_step == 0) {
        // Always fetch
        // MI = Memory Address Register In
        // CE = Program Counter Enabled
        console_log ( "PC to MAR" );
        control_word.set_value ( MI | CE );
        bus.set_value ( prog_ctr.get_value() );
        mem_addr.set_value ( bus.get_value() );
      } else if (ucode_step == 1) {
        // Always move from memory into the Instruction Register
        // RO = RAM Out
        // II = Instruction Register In
        // CE = Program Counter Enabled
        console_log ( "RAM to Instruction Register" );
        control_word.set_value ( RO | II | CE );
        let ram = memory[mem_addr.get_value()];
        bus.set_value ( ram );
        inst_op.set_value ( (ram >> 4) & 0x0f );
        inst_data.set_value ( ram & 0x0f );
        prog_ctr.set_value ( (prog_ctr.get_value() + 1) % 16 );
      } else {
        // Look at the instruction and step
        let operation = inst_op.get_value();
        let operand = inst_data.get_value();
        console_log ( "uExecute " + operation.toString(16) + "" + operand.toString(16) );
        if (operation == 0x00)        { // "NOP " + operand );
          console_log ( "Executing NOP " + operand + " at step " + ucode_step );
          // Do nothing
          control_word.set_value ( 0 );
        } else if (operation == 0x01) { // "LDA " + operand );
          console_log ( "Executing LDA " + operand );
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
          } else if (ucode_step == 3) {
            // RO = RAM Out
            // AI = A Register In
            console_log ( "Move RAM to A" );
            control_word.set_value ( RO | AI );
            bus.set_value ( memory[mem_addr.get_value()] );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x02) { // "ADD " + operand );
          console_log ( "Executing ADD " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  1  0  0  1  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  0  0  0  0  0 0  1
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
          } else if (ucode_step == 3) {
            // RO = RAM Out
            // BI = B Register In
            console_log ( "Move RAM to B" );
            control_word.set_value ( RO | BI );
            bus.set_value ( memory[mem_addr.get_value()] );
            b_reg.set_value ( bus.get_value() );
          } else if (ucode_step == 4) {
            // AI = A Register In
            // EO = Sum Out (E looks like sigma)
            // FI = Flags In
            console_log ( "Add put in A" );
            control_word.set_value ( AI | EO | FI );
            let result = a_reg.get_value() + b_reg.get_value();
            if (result > 0xff) {
              carry_bit.set_value ( 1 );
            } else {
              carry_bit.set_value ( 0 );
            }
            if (result == 0) {
              zero_bit.set_value ( 1 );
            } else {
              zero_bit.set_value ( 0 );
            }
            result = result & 0xff;
            sum_reg.set_value ( result );
            bus.set_value ( result );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x03) { // "SUB " + operand );
          console_log ( "Executing SUB " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  1  0  0  1  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
          } else if (ucode_step == 3) {
            // RO = RAM Out
            // BI = B Register In
            console_log ( "Move RAM to B" );
            control_word.set_value ( RO | BI );
            bus.set_value ( memory[mem_addr.get_value()] );
            b_reg.set_value ( bus.get_value() );
          } else if (ucode_step == 4) {
            // AI = A Register In
            // EO = Sum Out (E looks like sigma)
            // FI = Flags In
            // SU = Subtract Signal
            console_log ( "Subtract put in A" );
            control_word.set_value ( AI | EO | FI | SU );
            let result = a_reg.get_value() - b_reg.get_value();
            if (result >= 0x00) {
              carry_bit.set_value ( 1 );
            } else {
              carry_bit.set_value ( 0 );
            }
            if (result == 0) {
              zero_bit.set_value ( 1 );
            } else {
              zero_bit.set_value ( 0 );
            }
            result = result & 0xff;
            sum_reg.set_value ( result );
            bus.set_value ( result );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x04) { // "STA " + operand );
          console_log ( "Executing STA " + operand );
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
          } else if (ucode_step == 3) {
            // RI = RAM In
            // AO = A Register Out
            console_log ( "Move A to RAM" );
            control_word.set_value ( RI | AO );
            bus.set_value ( a_reg.get_value() );
            memory[mem_addr.get_value()] = bus.get_value();
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x05) { // "LDI " + operand );
          console_log ( "Executing LDI " + operand );
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // AI = A Register In
            console_log ( "Move InstData to A" );
            control_word.set_value ( IO | AI );
            bus.set_value ( inst_data.get_value() );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x06) { // "JMP " + operand );
          console_log ( "Executing JMP " + operand );
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // J  = Jump
            console_log ( "Move InstData to PC" );
            control_word.set_value ( IO | J );
            bus.set_value ( inst_data.get_value() );
            prog_ctr.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x07) { // "JC  " + operand );
          console_log ( "Executing JC " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  0  0  0  0  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // J  = Jump
            if (carry_bit.get_value() == 0) {
              console_log ( "No Carry No Jump" );
              control_word.set_value ( 0 );
            } else {
              console_log ( "Jump on Carry" );
              control_word.set_value ( IO | J );
              bus.set_value ( inst_data.get_value() );
              prog_ctr.set_value ( bus.get_value() );
            }
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x08) { // "JZ  " + operand );
          console_log ( "Executing JZ " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  0  0  0  0  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // J  = Jump
            if (zero_bit.get_value() == 0) {
              console_log ( "No Zero No Jump" );
              control_word.set_value ( 0 );
            } else {
              console_log ( "Jump on Zero" );
              control_word.set_value ( IO | J );
              bus.set_value ( inst_data.get_value() );
              prog_ctr.set_value ( bus.get_value() );
            }
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x09) { // "?09 " + operand );
          console_log ( "Executing ?9 " + operand );
        } else if (operation == 0x0a) { // "?0A " + operand );
          console_log ( "Executing ?A " + operand );
        } else if (operation == 0x0b) { // "?0B " + operand );
          console_log ( "Executing ?B " + operand );
        } else if (operation == 0x0c) { // "?0C " + operand );
          console_log ( "Executing ?C " + operand );
        } else if (operation == 0x0d) { // "?0D " + operand );
          console_log ( "Executing ?D " + operand );
        } else if (operation == 0x0e) { // "OUT " + operand );
          console_log ( "Executing OUT " + operand );
          if (ucode_step == 2) {
            // AO = A Register Out
            // OI = Output Register In
            control_word.set_value ( AO | OI );
            bus.set_value ( a_reg.get_value() );
            display_out.set_value ( bus.get_value() );
            console.log ( "OUT: " + bus.get_value() );
            display_out.set_digits ( String(bus.get_value()) );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x0f) { // "FX" Halt instruction ("HLT")
          control_word.set_value ( HT );
          clock.stop();
          stop();
        }
      }
    } else {
      // This is the alternate half of the clock cycle
    }
  } else {
    // Execute macro instructions

    // Update the ucode counter
    ucode_ctr.update ( clock.get_state() );

    if ( clock.get_state() && (ucode_ctr.get_state() == 3) ) {
      // Execute the current instruction
      let pc = prog_ctr.get_value();

      mem_addr.set_value ( pc );
      mem_data.set_value ( memory[pc] );
      let lower = memory[pc] & 0x0f;
      let upper = (memory[pc] >> 4) & 0x0f;

      inst_op.set_value ( upper );
      inst_data.set_value ( lower );

      if (upper == 0x00)        { // "NOP " + lower );
        // Do nothing
      } else if (upper == 0x01) { // "LDA " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        let value = memory[lower];
        a_reg.set_value ( value );
        sum_reg.set_value ( (a_reg.get_value() + b_reg.get_value()) );
      } else if (upper == 0x02) { // "ADD " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        let value = memory[lower];
        b_reg.set_value ( value );
        let result = a_reg.get_value() + b_reg.get_value();
        if (result > 0xff) {
          carry_bit.set_value ( 1 );
        } else {
          carry_bit.set_value ( 0 );
        }
        result = result & 0xff;
        sum_reg.set_value ( result );
        a_reg.set_value ( result );
      } else if (upper == 0x03) { // "SUB " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        let value = memory[lower];
        b_reg.set_value ( value );
        let result = a_reg.get_value() - b_reg.get_value();
        if (result >= 0x00) {
          carry_bit.set_value ( 1 );
        } else {
          carry_bit.set_value ( 0 );
        }
        if (result == 0) {
          zero_bit.set_value ( 1 );
        } else {
          zero_bit.set_value ( 0 );
        }
        result = result & 0xff;
        sum_reg.set_value ( result );
        bus.set_value ( result );
        a_reg.set_value ( bus.get_value() );

      } else if (upper == 0x04) { // "STA " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        memory[lower] = a_reg.get_value();
        sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
      } else if (upper == 0x05) { // "LDI " + lower );
        a_reg.set_value ( lower );
        sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
      } else if (upper == 0x06) { // "JMP " + lower );
        mem_addr.set_value ( lower );
        let value = memory[lower];
        mem_data.set_value ( memory[lower] );
        pc = lower - 1; // Jump before destination since pc will be incremented
      } else if (upper == 0x07) { // "JC  " + lower );
        if (carry_bit.get_value() != 0) {
          mem_addr.set_value ( lower );
          mem_data.set_value ( memory[lower] );
          let value = memory[lower];
          pc = lower - 1; // Jump before destination since pc will be incremented
        }
      } else if (upper == 0x08) { // "JZ  " + lower );
        if (zero_bit.get_value() != 0) {
          mem_addr.set_value ( lower );
          mem_data.set_value ( memory[lower] );
          let value = memory[lower];
          pc = lower - 1; // Jump before destination since pc will be incremented
        }
      } else if (upper == 0x09) { // "?09 " + lower );
      } else if (upper == 0x0a) { // "?0A " + lower );
      } else if (upper == 0x0b) { // "?0B " + lower );
      } else if (upper == 0x0c) { // "?0C " + lower );
      } else if (upper == 0x0d) { // "?0D " + lower );
      } else if (upper == 0x0e) { // "OUT " + lower );
        // Display the A Register as output
        console.log ( "Out = " + a_reg.get_value() );
        display_out.set_digits ( String(a_reg.get_value()) );
      } else if (upper == 0x0f) { // "FX" Halt instruction ("HLT")
        clock.stop();
        stop();
      }
      bus.randomize_bits();
      control_word.randomize_bits();
      // Increment the program counter as needed
      pc = (pc + 1) % 16;
      prog_ctr.set_value ( pc );
    }
  }

  // Update the canvas to cause a redraw of all changes

  update_canvas();

	count = count + 1;
}


function LDI_test_passed(x) {
  // Verify the correct results from LDI x
  micromacro.down = false; // false tests microcode, true tests macrocode
  // Set up the test case
  control_word.set_value ( 0 );
  clock.reset_button.reset();
  memory[0] = 0x50 | x; // LDI x
  memory[1] = 0xf0; // HLT
  memory[2] = 0xf0; // HLT
  // Run the processor until halted
  for (let i=0; i<100; i++) {
    exec_next();
    if (control_word.get_value(HT)[0]) {
      break; // Processor halted, so break out of execution loop
    }
  }
  // Verify the result
  if (a_reg.get_value() != x) {
    console.log ( "LDI Test expected A=" + x + ", but got A=" + a_reg.get_value() );
    passed = false;
    return ( false ); // Failed result, so return false
  }
  return ( true );
}

function ADD_test_passed(i,j) {
  // Verify the correct results from i+j
  micromacro.down = false; // false tests microcode, true tests macrocode
  // Set up the test case
  control_word.set_value ( 0 );
  clock.reset_button.reset();
  memory[0] = 0x14; // LDA 4
  memory[1] = 0x25; // ADD 5
  memory[2] = 0xf0; // HLT
  memory[3] = 0xf0; // HLT
  memory[4] = 0x00 | i; // Value of i
  memory[5] = 0x00 | j; // Value of j
  // Run the processor until halted
  for (let i=0; i<100; i++) {
    exec_next();
    if (control_word.get_value(HT)[0]) {
      break; // Processor halted, so break out of execution loop
    }
  }
  // Verify the result
  if (a_reg.get_value() != ((i+j)&0xff)) {
    console.log ( "ADD Test (" + i + "+" + j + ") expected A=" + (i+j) + ", but got A=" + a_reg.get_value() );
    return ( false );
  }
  // Verify the carry bit
  let expected_carry = 0;
  if (i+j > 255) {
    expected_carry = 1;
  }
  if (carry_bit.get_value() != expected_carry) {
    console.log ( "ADD Test (" + i + "+" + j + ") expected C=" + expected_carry + ", but got C=" + carry_bit.get_value() );
    return ( false );
  }
  // Verify the zero bit
  let expected_zero = 0;
  if (i+j == 0) {
    expected_zero = 1;
  }
  if (zero_bit.get_value() != expected_zero) {
    console.log ( "ADD Test (" + i + "+" + j + ") expected Z=" + expected_zero + ", but got Z=" + zero_bit.get_value() );
    return ( false );
  }
  return ( true );
}

function processor_test() {
  // This function can test execution of instructions
  micromacro.down = false; // false tests microcode, true tests macrocode
  let passed = false;

  // Run LDI tests:
  for (let x=0; x<16; x++) {
    console.log ( "LDI Test " + x );
    passed = LDI_test_passed(x);
    if (passed == false) {
      return ( false );
    }
  }

  // Run edge cases for ADD
  let add_cases = [ [0,0], [0,1], [1,1], [0xfe,1], [0xfe,2], [0xff,0], [0xff,1], [0xff,2], [0xff,0xff] ];
  for (let i=0; i<add_cases.length; i++) {
    console.log ( "ADD Test: " + add_cases[i][0] + " + " + add_cases[i][1] );
    passed = ADD_test_passed(add_cases[i][0],add_cases[i][1]);
    if (passed == false) {
      return ( false );
    }
    console.log ( "ADD Test: " + add_cases[i][1] + " + " + add_cases[i][0] );
    passed = ADD_test_passed(add_cases[i][1],add_cases[i][0]);
    if (passed == false) {
      return ( false );
    }
  }

  // Test sample cases across the range of inputs
  for (let x=0; x<256; x+=17) {
    for (let y=0; y<256; y+=11) {
      console.log ( "ADD Test: " + x + " + " + y );
      passed = ADD_test_passed(x,y);
      if (passed == false) {
        return ( false );
      }
      console.log ( "ADD Test: " + y + " + " + x );
      passed = ADD_test_passed(y,x);
      if (passed == false) {
        return ( false );
      }
    }
  }

  // Test randomly chosen sample cases
  for (let i=0; i<1000; i++) {
    let x = Math.floor ( 255 * Math.random() );
    if (x > 255) x = 255;
    let y = Math.floor ( 255 * Math.random() );
    if (y > 255) y = 255;
    console.log ( "ADD Test: " + x + " + " + y );
    passed = ADD_test_passed(x,y);
    if (passed == false) {
      return ( false );
    }
    console.log ( "ADD Test: " + y + " + " + x );
    passed = ADD_test_passed(y,x);
    if (passed == false) {
      return ( false );
    }
  }
  return ( true );
}


function cpu_reset() {
	is_idle = false;
	running = true;
	stop_running = true;
	run_stop();
	stop();
	run_counter = 1;
	main_loop.main_loop_counter = 0;
	ucode_ctr.reset();
	update_canvas();
}

function reset_callback() {
  clock.reset_button.reset();
	document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
	document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
	running = false;
}

function run_stop_callback() {
	running = !running;
	if (running) {
		document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
		document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
		run();
	} else {
		document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
		document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
		stop();
	}
}

window.onload = setup_canvas;

setup_canvas();

</script>

</head>

<body id='page' onload="setup_canvas()" onresize="update_canvas()" bgcolor="lightblue">

<table>

<tr>

<td>
<canvas id="drawing_area" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)"></canvas>
</td>

<td id="status_area" style="border: none;" valign="top">
<center>
Processor<br/>
<button type="button" onclick="run_stop_callback();" id="RunStop" style="background-color: #99FF99;">Run/<u>Stop</u></button>
<button type="button" onclick="reset_callback();">Reset</button>

</center>
<!-- <pre>-----------------</pre> -->
<pre id="next_instruction">Next goes here.
</pre>
<p></p>
<pre id="mem_status">Memory goes here.
</pre>
</td>

<td style="border: none;" valign="top">
<center>
Hex Code<br/>
<button type="button" onclick="load_hex()">Load</button><br/>
<textarea id="Hex Code" rows="20" cols="8"></textarea><br/>
<button type="button" onclick="zero_hex()">Zeros</button><br/>
</center>
</td>

<td style="border: none;" valign="top">
<center>
Source Code<br/>
<button type="button" onclick="assemble()">Assemble</button><br/>
<textarea id="Source Code" rows="20" cols="12"></textarea>
<br/>
<select id="examples" onchange="change_example()">
<option value="Examples">Examples</option>
<option value="NOP HLT">NOP HLT</option>
<option value="Add 14+28">Add 14+28</option>
<option value="Counter">Counter</option>
<option value="CountUpDown">Count U/D</option>
<option value="Fibonacci">Fibonacci</option>
<option value="Mult 3x5">Multiply 3x5</option>
<option value="Mult 7x8">Multiply 7x8</option>
<option value="Mult 15x15">Multiply 15x15</option>
<option value="Line Nums">Line Numbers</option>

<!-- <option value="Multiply">Multiply: E x F</option> May not work yet -->
</select>
</center>
</td>

</tr>
</table>


<hr/>
<center>
Instruction Set (a=address, v=value, x=don't care)
<hr/>
<table>
<tr><td><b>Name</b></td><td><b>Hex</b></td><td><b>Binary</b></td><td><b>Description</b></td></tr>
<tr><td>NOP</td><td>0x</td><td>0000 xxxx</td><td>No operation (does nothing)</td></tr>
<tr><td>LDA</td><td>1a</td><td>0001 addr</td><td>Load from memory (addr) into A Register</td></tr>
<tr><td>ADD</td><td>2a</td><td>0010 addr</td><td>Add from memory (addr) into A Register</td></tr>
<tr><td>SUB</td><td>3a</td><td>0011 addr</td><td>Subtract memory (addr) from A Register</td></tr>
<tr><td>STA</td><td>4a</td><td>0100 addr</td><td>Store to memory (addr) from A Register</td></tr>
<tr><td>LDI</td><td>5v</td><td>0101 value</td><td>Load immediate value into A Register</td></tr>
<tr><td>JMP</td><td>6a</td><td>0110 addr</td><td>Jump immediate</td></tr>
<tr><td>JC </td><td>7a</td><td>0111 addr</td><td>Jump on carry immediate</td></tr>
<tr><td>JZ </td><td>8a</td><td>1000 addr</td><td>Jump on zero immediate</td></tr>
<tr><td>---</td><td>9?</td><td>1001 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>A?</td><td>1010 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>B?</td><td>1011 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>C?</td><td>1100 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>D?</td><td>1101 ???? </td><td>Not defined</td></tr>
<tr><td>OUT</td><td>Ex</td><td>1110 xxxx</td><td>Output to LED panel (could use XXXX for In/Out channels)</td></tr>
<tr><td>HLT</td><td>Fx</td><td>1111 xxxx</td><td>Halt (could use XXXX for other instructions, push, pop, chs, etc.)</td></tr>
</table>
</center>

-->
</body>
</html>

