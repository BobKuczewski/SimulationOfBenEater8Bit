<!DOCTYPE html>

<html>

<head>
<title>Ben Eater's 8-bit Computer Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<script>

/* Instruction set:
NOP = 0000 XXXX
LDA = 0001 addr
ADD = 0010 addr
SUB = 0011 addr
STA = 0100 addr
LDI = 0101 value
JMP = 0110 addr
JC  = 0111 addr
JZ  = 1000 addr
    = 1001
    = 1010
    = 1011
    = 1100
    = 1101
OUT = 1110 XXXX  // Could use XXXX for In/Out and multiple channels
HLT = 1111 XXXX  // Could use XXXX for other instructions, push, pop, chs, etc.
*/

var memory = [ // Fibonacci Numbers up to 144
/* 0 */ 0x51,  // ldi 1   ; 1
/* 1 */ 0x4e,  // sta e   ; y(e) = 1
/* 2 */ 0x50,  // ldi 0   ; x = 0
/* 3 */ 0xe0,  // out
/* 4 */ 0x2e,  // add [e] ; x + y
/* 5 */ 0x4f,  // sta [f] ; z = x + y
/* 6 */ 0x1e,  // lda [e] ; y
/* 7 */ 0x4d,  // sta [d] ; x = y
/* 8 */ 0x1f,  // lda [f] ; z
/* 9 */ 0x4e,  // sta [e] ; y = z
/* a */ 0x1d,  // lda [d] ; x
/* b */ 0x70,  // jc  0   ; jump carry to next Fib
/* c */ 0x63,  // jmp 3   ; keep adding
/* d */ 0x00,  // x
/* e */ 0x00,  // y
/* f */ 0x00,  // z
];


function hex1 ( v ) {
	return ( (v % 16).toString(16).toUpperCase() );
}

function hex2 ( v ) {
	h = (v % 256).toString(16).toUpperCase();
	while (h.length < 2) {
		h = "0" + h;
	}
	return ( h );
}

function hex4 ( v ) {
	h = (v % 65536).toString(16).toUpperCase();
	while (h.length < 4) {
		h = "0" + h;
	}
	return ( h );
}

function display_memory() {
  mem_disp = document.getElementById('status');
  let txt = "  Memory\n";
  for (let i=0; i<memory.length; i++) {
    txt = txt + "  " + hex1(i) + " " + hex2(memory[i]) + "\n";
  }
  mem_disp.innerHTML = txt;
}

//var memory = [
//* 0 */ 0x1e,  // LDA E (ff)
//* 1 */ 0x55,  // LDI 5
//* 2 */ 0x2f,  // ADD F 5
//* 3 */ 0x3d,  // SUB F 1
//* 4 */ 0xf0,  // HLT
//* 5 */ 0x60,  // JMP 0
//* 6 */ 0x00,
//* 7 */ 0x00,
//* 8 */ 0x00,
//* 9 */ 0x00,
//* a */ 0x00,
//* b */ 0x00,
//* c */ 0x00,
//* d */ 0x01,
//* e */ 0xff,
//* f */ 0x05,
//];

/* Program to shift A along (works)
  0x18,
  0x19,
  0x1a,
  0x1b,
  0x1c,
  0x1d,
  0x1e,
  0x60, // Jump 0
  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80
*/
/* Program to multiply?
  0x1e,  // 00: LDA 14
  0x3c,  // 01: SUB 12
  0x76,  // 02: JC 6
  0x1d,  // 03: LDA 13
  0xe0,  // 04: OUT
  0xf0,  // 05: HLT
  0x4e,  // 06: STA 14
  0x1d,  // 07: LDA 13
  0x2f,  // 08: ADD 15
  0x4d,  // 09: STA 13
  0x60,  // 0A: JMP 0
  0x00,  // 0B:
  0x01,  // 0C: 1
  0x00,  // 0D: (product of x*y)
  0x07,  // 0E: (x)
  0x05   // 0F: (y)
*/

/*
// Program to shift A to the left
  0x18,  // 00: LDA 14
  0x19,
  0x1a,
  0x1b,
  0x1c,
  0x1d,
  0x1e,
  0x1f,

  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80
*/


var consoleDebug = false;

var gray_on = "#cccccc";
var gray_off = "#444444";
var red_on = "#ffcc88";
var red_off = "#bb2222";
var yellow_on = "#ffff00";
var yellow_off = "#e0980e";
var blue_on = "#bbccff";
var blue_off = "#162560";
var green_on = "#daff0c";
var green_off = "#185621";

function toggle_debug() {
  // consoleDebug = !consoleDebug;
  let debug = document.getElementById('debug');
  consoleDebug = debug.checked;
}

class Register {
  constructor ( name, nbits ) {
    if (consoleDebug) console.log ( "New Register " + name );
    this.nbits = nbits;
    this.reg_name = name;
    this.on_color = gray_on;
    this.off_color = gray_off;
    this.radius = 10;
    this.state = [ true ];
    this.position = [ [20,90] ];
  }
  get_state() {
    return ( this.state );
  }
  get_value() {
    let value = 0;
    let n = this.state.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      if (this.state[i]) {
        value = value | (0x01 << bit);
      }
      bit = bit - 1;
    }
    value = value & ((2**this.nbits)-1);
    return ( value );
  }
  set_value ( value ) {
    // The register indexes are bit positions, so reverse
    // value = 1101  gives [ 1, 0, 1, 1 ]
    value = value & 0xff;
    this.state = [];
    let n = this.position.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      // if ((value >> bit) & 0x01) > 0) {
      if ((value & (0x01 << bit)) > 0) {
        this.state.push ( true );
      } else {
        this.state.push ( false );
      }
      bit = bit - 1;
    }
  }
  randomize_bits () {
    for (let i=0; i<this.state.length; i++) {
      if (Math.random() > 0.5) {
        this.state[i] = true;
      } else {
        this.state[i] = false;
      }
    }
  }
  draw ( ctxt ) {
    // console.log ( "Draw Register " + this.reg_name );
    // Draw the Register lights
    for (let i=0; i<this.position.length; i++) {
      let s = false;
      if (i < this.state.length) {
        s = this.state[i];
      }
      if (s) {
        ctxt.fillStyle = this.on_color;
      } else {
        ctxt.fillStyle = this.off_color;
      }
      ctxt.beginPath();
      ctxt.arc(this.position[i][0], this.position[i][1], this.radius, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
    // console.log ( "  finished Draw Register " + this.reg_name );
  }
  toString() {
    let s = "Register " + this.reg_name + " = " + this.get_value();
    return ( s );
  }
}

class ClockModule extends Register {

  constructor (name,nbits) {
    super(name,nbits);
    this.state = false;
    this.clock_speed_button = [ [200,25,16] ];
    this.clock_auto_button = [ [false,121,29] ];
    this.clock_step_button = [ [true,69,32] ];
    this.clock_speeds = [ 1000, 200, 2 ];
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.position = [ 232, 6 ];
    this.radius = 5;
  }

  half_tick() {
    this.state = ! this.state;
  }

  get_speed_ms() {
    return ( this.clock_speed_button[0][0] );
  }

  mouse_up ( event ) {
    if ( (event.clientX >= this.clock_step_button[0][1]) && (event.clientX <= this.clock_step_button[0][1]+20) ) {
      if ( (event.clientY >= this.clock_step_button[0][2]) && (event.clientY <= this.clock_step_button[0][2]+20) ) {
        // if (consoleDebug) console.log ( "Clock up with " + event.clientX + ", " + event.clientY );
        step();
        update_canvas();
      }
    }
  }

  mouse_down ( event ) {
    if ( (event.clientX >= this.clock_step_button[0][1]) && (event.clientX <= this.clock_step_button[0][1]+20) ) {
      if ( (event.clientY >= this.clock_step_button[0][2]) && (event.clientY <= this.clock_step_button[0][2]+20) ) {
        // if (consoleDebug) console.log ( "Clock down with " + event.clientX + ", " + event.clientY );
        step();
        update_canvas();
      }
    }
    if ( (event.clientX >= this.clock_auto_button[0][1]) && (event.clientX <= this.clock_auto_button[0][1]+20) ) {
      if ( (event.clientY >= this.clock_auto_button[0][2]) && (event.clientY <= this.clock_auto_button[0][2]+20) ) {
        run_stop();
        this.clock_auto_button[0][0] = !this.clock_auto_button[0][0];
        // if (consoleDebug) console.log ( "auto toggled to " + this.clock_auto_button[0][0] );
        update_canvas();
      }
    }
    if ( (event.clientX >= this.clock_speed_button[0][1]-10) && (event.clientX <= this.clock_speed_button[0][1]+10) ) {
      if ( (event.clientY >= this.clock_speed_button[0][2]-10) && (event.clientY <= this.clock_speed_button[0][2]+10) ) {
        // if (consoleDebug) console.log ( "toggle speed button pressed" );
        for (let i=0; i<this.clock_speeds.length; i++) {
          // if (consoleDebug) console.log ( "Checking speed " + i + ": " + this.clock_speeds[i] );
          if (this.clock_speed_button[0][0] == this.clock_speeds[i]) {
            // if (consoleDebug) console.log ( "toggle speed" );
            if (i < (this.clock_speeds.length-1)) {
              this.clock_speed_button[0][0] = this.clock_speeds[i+1];
            } else {
              this.clock_speed_button[0][0] = this.clock_speeds[0];
            }
            // if (consoleDebug) console.log ( "toggled speed to " + this.clock_speed_button[0][0] );
            break;
          }
        }
        update_canvas();
      }
    }
  }

  draw(ctxt) {
    // Draw the "clock_speed_button"
    ctxt.fillStyle = "#ffffff44";
    if (this.clock_speed_button[0][0]>=1000) {
      ctxt.fillStyle = "#0000ff44";
    } else if (this.clock_speed_button[0][0]>=200) {
      ctxt.fillStyle = "#00ff0044";
    } else {
      ctxt.fillStyle = "#ff000044";
    }
    ctxt.fillRect( this.clock_speed_button[0][1]-20, this.clock_speed_button[0][2]-20, 20,20);

    // Draw the Run/Stop or "clock_auto_button" button
    ctxt.fillStyle = "#ffffff88";
    if (this.clock_auto_button[0][0]) {
      ctxt.fillStyle = "#ff888888";
    }
    ctxt.fillRect( this.clock_auto_button[0][1]-10, this.clock_auto_button[0][2]-10, 20,20);

    // Draw the Single Step or "clock_step_button" button
    ctxt.fillStyle = "#ffffff88";
    ctxt.fillRect( this.clock_step_button[0][1]-10, this.clock_step_button[0][2]-10, 20,20);

    // Draw the LED
    //console.log ( "ClockModule calling super.draw" );
    //super.draw(ctxt);
    //console.log ( "ClockModule done calling super.draw" );

    // Draw the Clock light
    if (this.state) {
      ctxt.fillStyle = blue_on;
    } else {
      ctxt.fillStyle = blue_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0], this.position[1], 5, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class uCodeCounter extends Register {

  constructor (name,nbits) {
    super("uCodeCounter",nbits);
    this.state = 0;
    this.ucode_ctr_LEDs = [ [false,33,395],[false,43,395],[false,53,395] ];

    this.ucode_state_LEDs = [ [false,66,390],
                              [true,76,390],
                              [true,86,390],
                              [true,97,390],
                              [true,108,390],
                              [false,120,390] ];
    //                        [false,124,390],
    //                        [false,128,390] ];
  }

  update ( clock_state ) {
    // Update the ucode counter on the appropriate clock edge
    if (!clock_state) {
      this.ucode_ctr_LEDs[0][0] = !this.ucode_ctr_LEDs[0][0];
      if (!this.ucode_ctr_LEDs[0][0]) {
        this.ucode_ctr_LEDs[1][0] = !this.ucode_ctr_LEDs[1][0];
        if (!this.ucode_ctr_LEDs[1][0]) {
          this.ucode_ctr_LEDs[2][0] = !this.ucode_ctr_LEDs[2][0];
        }
      }
    }

    // Update the ucode state based on the counter
    this.state = 0;
    if (this.ucode_ctr_LEDs[2][0]) {
      this.state = this.state | 0x04;
    }
    if (this.ucode_ctr_LEDs[1][0]) {
      this.state = this.state | 0x02;
    }
    if (this.ucode_ctr_LEDs[0][0]) {
      this.state = this.state | 0x01;
    }
    if (this.state > 5) {
      this.state = 0;
      this.ucode_ctr_LEDs[0][0] = false;
      this.ucode_ctr_LEDs[1][0] = false;
      this.ucode_ctr_LEDs[2][0] = false;
    }
    this.ucode_state_LEDs[0][0] = true;
    this.ucode_state_LEDs[1][0] = true;
    this.ucode_state_LEDs[2][0] = true;
    this.ucode_state_LEDs[3][0] = true;
    this.ucode_state_LEDs[4][0] = true;
    this.ucode_state_LEDs[5][0] = true;
    this.ucode_state_LEDs[this.state][0] = false;

    // console.log ( "this.state before pc = " + this.state );
    return ( this.state );
  }

  draw_ucode_ctr ( ctxt ) {
    // Draw the Microcode Counter
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      if (this.ucode_ctr_LEDs[i][0]) {
        ctxt.fillStyle = red_on;
      } else {
        ctxt.fillStyle = red_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_ctr_LEDs[i][1], this.ucode_ctr_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw_ucode_state ( ctxt ) {
    // Draw the Microcode State
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      if (this.ucode_state_LEDs[i][0]) {
        ctxt.fillStyle = green_on;
      } else {
        ctxt.fillStyle = green_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_state_LEDs[i][1], this.ucode_state_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw(ctxt) {
    this.draw_ucode_ctr ( ctxt );
    this.draw_ucode_state ( ctxt );
  }
}


class ARegister extends Register {
  constructor (name,nbits) {
    super("A Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [ true, false, true, false, false, false, true, true ];
    this.position = [ [422,134],[432,134],[443,134],[453,134],[464,134],[474,134],[485,134],[495,134] ];
  }
  draw(ctxt) {
    super.draw(ctxt);
  }
}


class BRegister extends Register {
  constructor (name,nbits) {
    super("B Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [424,290],[434,290],[445,290],[455,290],[466,290],[477,290],[488,290],[498,290] ];
  }
  draw(ctxt) {
    super.draw(ctxt);
  }
}


class SumRegister extends Register {
  constructor (name,nbits) {
    super("Sum Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [368,220],[377,221],[389,221],[400,222],[409,222],[419,222],[429,222],[441,220] ];
  }
  draw(ctxt) {
    super.draw(ctxt);
  }
}

class CarryRegister extends Register {
  constructor (name,nbits) {
    super("Carry Bit",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [562,133] ];
  }
  draw(ctxt) {
    super.draw(ctxt);
  }
}

class ZeroRegister extends Register {
  constructor (name,nbits) {
    super("Zero Bit",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [572,133] ];
  }
  /*
  draw(ctxt) {
    super.draw(ctxt);
  } */
}


class ProgramCounter extends Register {
  constructor (name,nbits) {
    super("Program Counter",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [386,6], [395,6], [404,6], [413,6] ];
  }
  draw(ctxt) {
    super.draw(ctxt);
  }
}


class InstructionOperation extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [true,false,false,false];
    this.position = [ [148,369], [157,370], [166,371], [177,371] ];
  }
  draw(ctxt) {
    super.draw(ctxt);
  }
}
class InstructionData extends Register {
  constructor (name,nbits) {
    super("Instruction Data",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,true];
    this.position = [ [187,371], [197,371], [207,371], [217,371] ];
  }
  draw(ctxt) {
    super.draw(ctxt);
  }
}



function decode ( instruction ) {
  let out = "";
  let lower = instruction & 0x0f;
  let upper = (instruction >> 4) & 0x0f;
  if (upper == 0x00) out = ( "NOP " + lower );
  if (upper == 0x01) out = ( "LDA " + lower );
  if (upper == 0x02) out = ( "ADD " + lower );
  if (upper == 0x03) out = ( "SUB " + lower );
  if (upper == 0x04) out = ( "STA " + lower );
  if (upper == 0x05) out = ( "LDI " + lower );
  if (upper == 0x06) out = ( "JMP " + lower );
  if (upper == 0x07) out = ( "JC  " + lower );
  if (upper == 0x08) out = ( "JZ  " + lower );
  if (upper == 0x09) out = ( "?09 " + lower );
  if (upper == 0x0a) out = ( "?0A " + lower );
  if (upper == 0x0b) out = ( "?0B " + lower );
  if (upper == 0x0c) out = ( "?0C " + lower );
  if (upper == 0x0d) out = ( "?0D " + lower );
  if (upper == 0x0e) out = ( "OUT " + lower );
  if (upper == 0x0f) out = ( "HLT " + lower );
  return ( out );
}


clock = new ClockModule("Clock", 1);
ucode_ctr = new uCodeCounter("uCodeCounter", 3 );
prog_ctr = new ProgramCounter("ProgramCounter", 4);
inst_op = new InstructionOperation("InstructionOp", 4);
inst_data = new InstructionData("InstructionData", 4);
a_reg = new ARegister("RegisterA", 8);
b_reg = new BRegister("RegisterB", 8);
sum_reg = new SumRegister("Sum", 8);
carry_bit = new CarryRegister("Carry", 1);
zero_bit = new ZeroRegister("Zero", 1);

var run_mode_LEDs = [ [true,45,111] ];  // Green near Address Register DIP Switch
var program_mode_LEDs = [ [true,55,111] ];  // Red near Address Register DIP Switch

var bus_value_LEDs = [ [false,289,6],
                       [true,298,6],
                       [false,307,6],
                       [true,316,6],
                       [false,325,6],
                       [true,334,6],
                       [false,343,6],
                       [true,352,6] ];

var mem_address_LEDs = [ [false,147,145],
                         [true,157,146],
                         [false,166,145],
                         [true,176,146] ];

var mem_contents_LEDs = [ [true,138,225],
                          [false,147,225],
                          [true,156,225],
                          [true,166,225],
                          [false,176,225],
                          [true,187,225],
                          [false,198,225],
                          [true,208,225] ];

var control_word_LEDs = [ [true,366,497],
                          [false,376,497],
                          [false,385,497],
                          [true,394,497],
                          [false,403,497],
                          [true,412,497],
                          [false,421,497],
                          [true,430,497],
                          [false,439,497],
                          [true,448,497],
                          [false,457,497],
                          [true,466,497],
                          [false,475,497],
                          [true,484,497],
                          [false,493,497],
                          [true,502,497] ];

function randomize_register_bits ( reg ) {
  for (let i=0; i<reg.length; i++) {
    if (Math.random() > 0.5) {
      reg[i][0] = 1;
    } else {
      reg[i][0] = 0;
    }
  }
}

function randomize_all_bits () {
  randomize_register_bits ( control_word_LEDs );
  randomize_register_bits ( mem_contents_LEDs );
  // randomize_register_bits ( instr_low_LEDs );
  // randomize_register_bits ( instr_high_LEDs );
  // randomize_register_bits ( zero_flag_LEDs );
  // randomize_register_bits ( carry_flag_LEDs );
  // randomize_register_bits ( sum_register_LEDs );
  // randomize_register_bits ( register_B_LEDs );
  // randomize_register_bits ( register_A_LEDs );
  randomize_register_bits ( mem_address_LEDs );
  randomize_register_bits ( bus_value_LEDs );
  // randomize_register_bits ( ucode_state_LEDs );
  // randomize_register_bits ( ucode_ctr_LEDs );
  // randomize_register_bits ( program_ctr_LEDs );
}


var image = new Image();
var image_loaded = false;

function update_canvas() {
  display_memory();
  var canvas = document.getElementById('drawing_area');
  // if (consoleDebug) console.log ( "update_canvas" );
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;
    if (image_loaded) {
      // Draw the background image
      ctxt.drawImage(image,0,0);

      // Draw the modules
      // console.log ( "About to draw clock" );
      clock.draw(ctxt);
      ucode_ctr.draw(ctxt);

      // Draw the x1 light
      for (let i=0; i<run_mode_LEDs.length; i++) {
        if (run_mode_LEDs[i][0]) {
          ctxt.fillStyle = green_on;
        } else {
          ctxt.fillStyle = green_off;
        }
        ctxt.beginPath();
        ctxt.arc(run_mode_LEDs[i][1], run_mode_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }
      // Draw the x2 light
      for (let i=0; i<program_mode_LEDs.length; i++) {
        if (program_mode_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(program_mode_LEDs[i][1], program_mode_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Program Counter
      prog_ctr.draw ( ctxt );

      // Draw the Bus lights
      for (let i=0; i<bus_value_LEDs.length; i++) {
        if (bus_value_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(bus_value_LEDs[i][1], bus_value_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Memory Address lights
      for (let i=0; i<mem_address_LEDs.length; i++) {
        if (mem_address_LEDs[i][0]) {
          ctxt.fillStyle = yellow_on;
        } else {
          ctxt.fillStyle = yellow_off;
        }
        ctxt.beginPath();
        ctxt.arc(mem_address_LEDs[i][1], mem_address_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      a_reg.draw ( ctxt );

      b_reg.draw ( ctxt );

      sum_reg.draw ( ctxt );

      carry_bit.draw ( ctxt );
      zero_bit.draw ( ctxt );

      inst_op.draw ( ctxt );
      inst_data.draw ( ctxt );

      // Draw the Memory Contents lights
      for (let i=0; i<mem_contents_LEDs.length; i++) {
        if (mem_contents_LEDs[i][0]) {
          ctxt.fillStyle = red_on;
        } else {
          ctxt.fillStyle = red_off;
        }
        ctxt.beginPath();
        ctxt.arc(mem_contents_LEDs[i][1], mem_contents_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }

      // Draw the Control Word lights
      for (let i=0; i<control_word_LEDs.length; i++) {
        if (control_word_LEDs[i][0]) {
          ctxt.fillStyle = blue_on;
        } else {
          ctxt.fillStyle = blue_off;
        }
        ctxt.beginPath();
        ctxt.arc(control_word_LEDs[i][1], control_word_LEDs[i][2], 5, 0, 2 * Math.PI);
        ctxt.fill();
        ctxt.closePath();
      }


      // ctxt.fillStyle = "#ff8888";
      // ctxt.fillRect((w/2)-10,(h/2)-10,20,20);

    };
  }
}

function setup_canvas() {
  var canvas = document.getElementById('drawing_area');
  // if (consoleDebug) console.log ( "setup_canvas" );
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;

    image.onload = function () {
      image_loaded = true;

      // Draw the background image
      ctxt.drawImage(image,0,0);

      update_canvas();
    };
    image.src = 'computer_background_640.png';
  }
}

function draw_canvas() {
  // window.alert ( "Draw Canvas" );
  var drawing_area = document.getElementById ( "drawing_area" );
  if (drawing_area != null) {
    var ctxt = drawing_area.getContext("2d");
    var w = drawing_area.width;
    var h = drawing_area.height;

    image.onload = function () {
        ctxt.drawImage(image,5,5);
    };

  }
}

function mouse_up ( event ) {
  clock.mouse_up ( event );
}

function mouse_down ( event ) {
  clock.mouse_down ( event );
}

stopRunning = false;
function mainLoop()
{
   // if (consoleDebug) console.log("sim: enter mainLoop");

   if (mainLoop.bInMainLoop)
      return;

   mainLoop.bInMainLoop = true;
   mainLoop.bStayInLoop = false;    // by default, release main loop

   if (typeof mainLoop.nCounter == "undefined")
      mainLoop.nCounter = 0;

   if (!stopRunning) {
	   exec_next();
   }

   ++mainLoop.nCounter;

   mainLoop.bStayInLoop = true;

   if (stopRunning)
	  mainLoop.bStayInLoop = false;

   mainLoop.bInMainLoop = false;

   if (mainLoop.bStayInLoop)
      setTimeout ("mainLoop()", clock.get_speed_ms()); // Call mainLoop 1ms from now

   // if (consoleDebug) console.log("sim: exit mainLoop");

   return mainLoop.bStayInLoop;
} // mainLoop

running = false;
run_counter = 1;
function run_stop() {
	running = !running;
	if (running) {
//x		document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
//x		document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
		run();
	} else {
//x		document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
//x		document.getElementById('RunStop').setAttribute("style", "");
		stop();
//x		if (consoleDebug) console.log ( "Opcodes Used:" );
//x		for (i=0; i<16; i++) {
//x			s = " " + hex2(i) + ":  ";
//x			for (j=0; j<16; j++) {
//x				s += " " + hex1(used_ops[(16*i)+j]);
//x			}
//x			if (consoleDebug) console.log ( s + "\n" );
//x		}
		// if (consoleDebug) console.log ( "Used:\n" + used_ops );
	}
}
function run() {
	stopRunning = false;
	mainLoop.nCounter = 0;
	mainLoop();
}
function stop() {
	running = false;
	mainLoop.bStayInLoop = false;
	stopRunning = true;
}
function step() {
	if (running == false) {
		exec_next();
	}
}


var count = 0;
function exec_next() {

  // Toggle the clock
  clock.half_tick();

  // Update the ucode counter
  ucode_ctr.update ( clock.get_state() );


  if ( clock.get_state() && (ucode_ctr.get_state() == 3) ) {
    // Execute the current instruction
    let pc = prog_ctr.get_value();
    if (consoleDebug) console.log ( "Execute " + hex2(memory[pc]) + " = " + decode(memory[pc]) );

    let lower = memory[pc] & 0x0f;
    let upper = (memory[pc] >> 4) & 0x0f;

    inst_op.set_value ( upper );
    inst_data.set_value ( lower );

    if (upper == 0x00)        { // "NOP " + lower );
    } else if (upper == 0x01) { // "LDA " + lower );
      if (consoleDebug) console.log ( "  A = memory[" + lower + "] = " + memory[lower] );
      let value = memory[lower];
      a_reg.set_value ( value );
      sum_reg.set_value ( (a_reg.get_value() + b_reg.get_value()) );
    } else if (upper == 0x02) { // "ADD " + lower );
      if (consoleDebug) console.log ( "  B = memory[" + lower + "] = " + memory[lower] );
      let value = memory[lower];
      b_reg.set_value ( value );
      let result = a_reg.get_value() + b_reg.get_value();
      if (result > 0xff) {
        carry_bit.set_value ( 1 );
      } else {
        carry_bit.set_value ( 0 );
      }
      result = result & 0xff;
      sum_reg.set_value ( result );
      a_reg.set_value ( result );
    } else if (upper == 0x03) { // "SUB " + lower );
      if (consoleDebug) console.log ( "  B = memory[" + lower + "] = " + memory[lower] );
      let value = memory[lower];
      b_reg.set_value ( value );
      sum_reg.set_value ( a_reg.get_value() - b_reg.get_value() );
      a_reg.set_value ( sum_reg.get_value() );
    } else if (upper == 0x04) { // "STA " + lower );
      memory[lower] = a_reg.get_value();
      sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
    } else if (upper == 0x05) { // "LDI " + lower );
      if (consoleDebug) console.log ( "  A = " + lower );
      a_reg.set_value ( lower );
      sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
    } else if (upper == 0x06) { // "JMP " + lower );
      if (consoleDebug) console.log ( "  JMP " + lower );
      let value = memory[lower];
      pc = lower - 1; // Jump before destination since pc will be incremented
    } else if (upper == 0x07) { // "JC  " + lower );
      if (carry_bit.get_value() != 0) {
        let value = memory[lower];
        pc = lower - 1; // Jump before destination since pc will be incremented
      }
    } else if (upper == 0x08) { // "JZ  " + lower );
    } else if (upper == 0x09) { // "?09 " + lower );
    } else if (upper == 0x0a) { // "?0A " + lower );
    } else if (upper == 0x0b) { // "?0B " + lower );
    } else if (upper == 0x0c) { // "?0C " + lower );
    } else if (upper == 0x0d) { // "?0D " + lower );
    } else if (upper == 0x0e) { // "OUT " + lower );
      console.log ( "### Out = " + a_reg.get_value() );
    } else if (upper == 0x0f) { // "HLT " + lower );
      stop();
      clock.clock_auto_button[0][0] = false;
      stop();
    }

    // Increment the program counter as needed
    pc = (pc + 1) % 16;
    // console.log ( "PC = " + pc );
    prog_ctr.set_value ( pc );
    // console.log ( "pc = " + pc );
    // console.log ( "prog_ctr = " + prog_ctr );
  }

  // Set all others to random values (used during development)
  randomize_all_bits();
  update_canvas();

	// if (consoleDebug) console.log ( "Executed " + count );
	count = count + 1;
}

function cpu_reset() {
	is_idle = false;
	running = true;
	stopRunning = true;
	run_stop();
	stop();
	run_counter = 1;
	mainLoop.nCounter = 0;
}


window.onload = setup_canvas;

setup_canvas();

</script>

</head>

<body id='page' onload="setup_canvas()" onresize="update_canvas()" bgcolor="lightblue">
<!--body id='page' bgcolor="lightblue"-->

<table>
<tr><td>
<canvas id="drawing_area" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)"></canvas>
</td>
<td id="status_area">
<input type="checkbox" id="debug" checked onclick="toggle_debug();">Debug</input>
<p></p>
<pre id="status">Mem goes here
</pre>
</td></tr>
</table>

</body>
