<!DOCTYPE html>

<html>

<head>
<title>Ben Eater's 8-bit Computer Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<script>


var memory = [ // Fibonacci Numbers up to 144
/* 0 */ 0x51,  // ldi 1   ; 1
/* 1 */ 0x4e,  // sta e   ; y(e) = 1
/* 2 */ 0x50,  // ldi 0   ; x = 0
/* 3 */ 0x2e,  // add [e] ; x + y
/* 4 */ 0x4f,  // sta [f] ; z = x + y
/* 5 */ 0x1e,  // lda [e] ; y
/* 6 */ 0x4d,  // sta [d] ; x = y
/* 7 */ 0x1f,  // lda [f] ; z
/* 8 */ 0x4e,  // sta [e] ; y = z
/* 9 */ 0x1d,  // lda [d] ; x
/* a */ 0xe0,  // out
/* b */ 0x70,  // jc  0   ; jump carry to next Fib
/* c */ 0x63,  // jmp 3   ; keep adding
/* d */ 0x00,  // x
/* e */ 0x00,  // y
/* f */ 0x00,  // z
];


function hex1 ( v ) {
	return ( (v % 16).toString(16).toUpperCase() );
}

function hex2 ( v ) {
	h = (v % 256).toString(16).toUpperCase();
	while (h.length < 2) {
		h = "0" + h;
	}
	return ( h );
}

function hex4 ( v ) {
	h = (v % 65536).toString(16).toUpperCase();
	while (h.length < 4) {
		h = "0" + h;
	}
	return ( h );
}

function display_status() {
  let txt = "";
  let next_instr = document.getElementById('next_instruction');
  let npc = prog_ctr.get_value();
  let no = memory[npc];
  txt = " Next:\n  " + hex1(npc) + ":" + hex2(no) + " " + decode(no) + "\n";
  next_instr.innerHTML = txt;

  let mem_disp = document.getElementById('mem_status');
  txt = " Memory:\n";
  for (let i=0; i<memory.length; i++) {
    let p = "";
    if (i == npc) {
      p = " <<---";
    }
    txt = txt + "  " + hex1(i) + " " + hex2(memory[i]) + p + "\n";
  }
  mem_disp.innerHTML = txt;
}

function single_spaces ( s ) {
  let ss = s.trim();
  while (ss.indexOf('  ') >= 0) {
    ss = ss.replaceAll('  ',' ');
  }
  return ( ss );
}


function load_hex() {
  let hex = document.getElementById("Hex Code").value;
  hex = single_spaces ( hex );
  if (hex.length > 0) {
    let hex_list = hex.trim().replaceAll('\n',' ').replace('  ',' ').split(' ');
    for (let i=0; i<hex_list.length; i++) {
      hex_list[i] = parseInt ( hex_list[i], 16 );
    }
    memory = hex_list;
    while (memory.length < 16) {
      memory.push(0);
    }
  }
  update_canvas();
}

function assemble() {
  let asm = document.getElementById("Source Code").value;
  let asm_list = asm.trim().replaceAll('\r','\n').split('\n');
  let instr_list = [];
  for (let i=0; i<asm_list.length; i++) {
    if (asm_list[i].trim().length > 0) {
      instr_list.push ( asm_list[i].trim() );
    }
  }
  for (let i=0; i<instr_list.length; i++) {
    instr_list[i] = single_spaces ( instr_list[i] );
  }
  let hex_code = "";
  for (let i=0; i<instr_list.length; i++) {
    let opcode = encode ( instr_list[i] );
    hex_code = hex_code + hex2(opcode) + "\n";
  }
  document.getElementById("Hex Code").value = hex_code;
}

function change_example() {
  if (document.getElementById("examples").value == "Examples") {
    xmemory = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    document.getElementById("Source Code").value = "";
    // document.getElementById("Hex Code").value = "";
  } else if (document.getElementById("examples").value == "No Ops") {
    xmemory = [ // No Ops
    /* 0 */ 0,
    /* 1 */ 0,
    /* 2 */ 0xff,
    /* 3 */ 0,
    /* 4 */ 0,
    /* 5 */ 0,
    /* 6 */ 0,
    /* 7 */ 0,
    /* 8 */ 0,
    /* 9 */ 0,
    /* a */ 0,
    /* b */ 0,
    /* c */ 0,
    /* d */ 0,
    /* e */ 0,
    /* f */ 0,
    ];
    document.getElementById("Source Code").value = "0 NOP\n0 NOP\n0 HLT\n";
    // document.getElementById("Hex Code").value = "00\n00\nff\n";
  } else if (document.getElementById("examples").value == "All Legal") {
    xmemory = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    document.getElementById("Source Code").value =
      "0 NOP 0\n1 LDA 1\n2 ADD 2\n3 SUB 3\n4 STA 4\n5 LDI 5\n6 JMP 6\n7 JC 7\n" +
      "8 JZ 8\n9 OUT E\nA HLT F\nB 9\nC A\nD B\nE C\nF D\n";
  } else if (document.getElementById("examples").value == "All Ops") {
    xmemory = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    document.getElementById("Source Code").value =
      "0 NOP 0\n1 LDA 1\n2 ADD 2\n3 SUB 3\n4 STA 4\n5 LDI 5\n6 JMP 6\n7 JC 7\n" +
      "8 JZ 8\nE OUT E\nF HLT F\n9 9 9\nA A A\nB B B\nC C C\nD D D\n";
  } else if (document.getElementById("examples").value == "Test LDA") {
    xmemory = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    document.getElementById("Source Code").value =
      "0 LDA A\n1 LDA B\n2 LDA C\n3 LDA D\n4 LDA E\n5 LDA F\n6 LDA A\n" +
      "7 LDA B\n8 LDA C\n9 LDA D\nA 1\nB 2\nC 3\nD 4\nE 5\nF 6\n";
  } else if (document.getElementById("examples").value == "Test LDI") {
    xmemory = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 LDI 2\n2 LDI 3\n3 LDI 4\n4 LDI 5\n5 LDI 6\n6 LDI 7\n7 LDI 8\n" +
      "8 LDI F\n9 LDI E\nA LDI D\nB LDI C\nC LDI B\nD LDI A\nE LDI 9\nF LDI 0\n";
  } else if (document.getElementById("examples").value == "Test JMP") {
    xmemory = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 JMP 4\n2 LDI 8\n3 LDI 9\n4 LDI 2\n5 JMP 7\n6 LDI A\n7 LDI 3\n" +
      "8 JMP F\n9 LDI B\nA LDI 4\nB JMP D\nC LDI C\nD LDI 5\nE JMP 0\nF JMP A\n";
  } else if (document.getElementById("examples").value == "Test OUT") {
    xmemory = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 OUT\n2 LDI 2\n3 OUT\n4 LDI 3\n5 OUT\n6 LDI 4\n7 OUT\n" +
      "8 LDI 5\n9 OUT\nA LDI 4\nB OUT\nC LDI 3\nD OUT\nE LDI 2\nF OUT\n";
  } else if (document.getElementById("examples").value == "Counter") {
    xmemory = [ // Count forever
    /* 0 */ 0x51,  // ldi 1   ; 1
    /* 1 */ 0x4f,  // sta f   ; r[f] = 1
    /* 2 */ 0x50,  // ldi 0   ; a = 0
    /* 3 */ 0x2f,  // add [f] ; a = a + 1
    /* 4 */ 0xe0,  // out     ;
    /* 5 */ 0x63,  // jmp 3   ;
    /* 6 */ 0x4d,  // sta [d] ; x = y
    /* 7 */ 0x1f,  // lda [f] ; z
    /* 8 */ 0x4e,  // sta [e] ; y = z
    /* 9 */ 0x1d,  // lda [d] ; x
    /* a */ 0xe0,  // out
    /* b */ 0x70,  // jc  0   ; jump carry to next Fib
    /* c */ 0x63,  // jmp 3   ; keep adding
    /* d */ 0x00,  // x
    /* e */ 0x00,  // y
    /* f */ 0x00,  // value
    ];
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 STA F\n2 LDI 0\n3 ADD F\n4 OUT\n5 JMP 3\n6 STA D\n7 LDA F\n" +
      "8 STA E\n9 LDA D\nA OUT\nB JC 0\nC JMP 3\nD 0\nE 0\nF 0\n";
    // document.getElementById("Hex Code").value =
    //   "51 4f 50 2f e0 63 4d 1f 4e 1d e0 70 63 00 00 00".trim().split(' ').join('\n');
  } else if (document.getElementById("examples").value == "Add Halt") {
    xmemory = [ // Count and halt
    /* 0 */ 0x51,  // ldi 1   ; 1
    /* 1 */ 0x4f,  // sta f   ; r[f] = 1
    /* 2 */ 0x51,  // ldi 1   ; a = 1
    /* 3 */ 0x2f,  // add [f] ; a = a + 1
    /* 4 */ 0xe0,  // out     ;
    /* 5 */ 0x4f,  // sta f   ;
    /* 6 */ 0x52,  // ldi 2   ; a = 2
    /* 7 */ 0x2f,  // add [f] ; a = a + 2
    /* 8 */ 0xe0,  // out     ;
    /* 9 */ 0x4f,  // sta f   ;
    /* a */ 0x53,  // ldi 3   ; a = 3
    /* b */ 0x2f,  // add [f] ; a = a + 3
    /* c */ 0xe0,  // out     ;
    /* d */ 0x4f,  // sta f   ;
    /* e */ 0xff,  // halt
    /* f */ 0x00,  // value
    ];
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 STA F\n2 LDI 1\n3 ADD F\n4 OUT\n5 STA F\n6 LDI 2\n7 ADD F\n" +
      "8 OUT\n9 STA F\nA LDI 3\nB ADD F\nC OUT\nD STA F\nE HLT\nF 0\n";
    // document.getElementById("Hex Code").value =
    //  "51 4f 51 2f e0 4f 52 2f e0 4f 53 2f e0 4f ff 00".trim().split(' ').join('\n');
  } else if (document.getElementById("examples").value == "Fibonacci") {
    xmemory = [ // Fibonacci Numbers up to 144
    /* 0 */ 0x51,  // ldi 1   ; 1
    /* 1 */ 0x4e,  // sta e   ; y(e) = 1
    /* 2 */ 0x50,  // ldi 0   ; x = 0
    /* 3 */ 0x2e,  // add [e] ; x + y
    /* 4 */ 0x4f,  // sta [f] ; z = x + y
    /* 5 */ 0x1e,  // lda [e] ; y
    /* 6 */ 0x4d,  // sta [d] ; x = y
    /* 7 */ 0x1f,  // lda [f] ; z
    /* 8 */ 0x4e,  // sta [e] ; y = z
    /* 9 */ 0x1d,  // lda [d] ; x
    /* a */ 0xe0,  // out
    /* b */ 0x70,  // jc  0   ; jump carry to next Fib
    /* c */ 0x63,  // jmp 3   ; keep adding
    /* d */ 0x00,  // x
    /* e */ 0x00,  // y
    /* f */ 0x00,  // z
    ];
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 STA E\n2 LDI 0\n3 ADD E\n4 STA F\n5 LDA E\n6 STA D\n7 LDA F\n" +
      "8 STA E\n9 LDA D\nA OUT\nB JC 0\nC JMP 3\nD 0\nE 0\nF 0\n";
    // document.getElementById("Hex Code").value =
    //   "51 4e 50 2e 4f 1e 4d 1f 4e 1d e0 70 63 00 00 00".trim().split(' ').join('\n');
  } else if (document.getElementById("examples").value == "Multiply") {
    xmemory = [ // Multiply values in [e] and [f]
      0x1e,  // 00: LDA 14
      0x3c,  // 01: SUB 12
      0x76,  // 02: JC 6
      0x1d,  // 03: LDA 13
      0xe0,  // 04: OUT
      0xf0,  // 05: HLT
      0x4e,  // 06: STA 14
      0x1d,  // 07: LDA 13
      0x2f,  // 08: ADD 15
      0x4d,  // 09: STA 13
      0x60,  // 0A: JMP 0
      0x00,  // 0B:
      0x01,  // 0C: 1
      0x00,  // 0D: (product of x*y)
      0x07,  // 0E: (x)
      0x05   // 0F: (y)
    ];
  }
  display_status();
  update_canvas();
}


var consoleDebug = false;

var gray_on = "#cccccc";
var gray_off = "#444444";
var red_on = "#ff6060";
var red_off = "#880000";
var yellow_on = "#ffff00";
var yellow_off = "#705010";
var blue_on = "#bbccff";
var blue_off = "#304090";
var green_on = "#80ff08";
var green_off = "#185621";

function toggle_debug() {
  let debug = document.getElementById('debug');
  consoleDebug = debug.checked;
}

class Register {
  constructor ( name, nbits ) {
    if (consoleDebug) console.log ( "New Register " + name );
    this.nbits = nbits;
    this.reg_name = name;
    this.on_color = gray_on;
    this.off_color = gray_off;
    this.radius = 10;
    this.state = [ true ];
    this.position = [ [20,90] ];
  }
  get_state() {
    return ( this.state );
  }
  get_value() {
    let value = 0;
    let n = this.state.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      if (this.state[i]) {
        value = value | (0x01 << bit);
      }
      bit = bit - 1;
    }
    value = value & ((2**this.nbits)-1);
    return ( value );
  }
  set_value ( value ) {
    // The register indexes are bit positions, so reverse
    // value = 1101  gives [ 1, 0, 1, 1 ]
    value = value & ( (2 ** this.nbits) - 1 ); // Mask off any higher order bits
    this.state = [];
    let n = this.position.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      // if ((value >> bit) & 0x01) > 0) {
      if ((value & (0x01 << bit)) > 0) {
        this.state.push ( true );
      } else {
        this.state.push ( false );
      }
      bit = bit - 1;
    }
  }
  randomize_bits () {
    for (let i=0; i<this.state.length; i++) {
      if (Math.random() > 0.5) {
        this.state[i] = true;
      } else {
        this.state[i] = false;
      }
    }
  }
  draw ( ctxt ) {
    // console.log ( "Draw Register " + this.reg_name );
    // Draw the Register lights
    for (let i=0; i<this.position.length; i++) {
      let s = false;
      if (i < this.state.length) {
        s = this.state[i];
      }
      if (s) {
        ctxt.fillStyle = this.on_color;
      } else {
        ctxt.fillStyle = this.off_color;
      }
      ctxt.beginPath();
      ctxt.arc(this.position[i][0], this.position[i][1], this.radius, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }
  toString() {
    let s = "Register " + this.reg_name + " = " + this.get_value();
    return ( s );
  }
}


class Button {
  constructor ( name, center_x, center_y, w, h ) {
    this.button_name = name;
    this.down_color = "#ffcccc80";
    this.up_color   = "#ccccff80";
    this.down = false;
    this.center_x = center_x;
    this.center_y = center_y;
    this.width = w;
    this.height = h;
    this.corner_x = this.center_x - (this.width/2);
    this.corner_y = this.center_y - (this.height/2);
  }
  get_corrected_coords ( event ) {
    // This function is needed on browsers where offsetX and offsetY are not correct.
    let offsets = [];
    let target = event.target || event.srcElement;
    let rect = target.getBoundingClientRect();
    let offsetX = event.clientX - rect.left;
    let offsetY = event.clientY - rect.top;
    let corrected = [offsetX, offsetY];
    return corrected;
  }
  set_down() {
    this.down = true;
  }
  set_up() {
    this.down = false;
  }
  set_down_color ( color ) {
    this.down_color = color;
  }
  set_up_color ( color ) {
    this.up_color = color;
  }
  draw(ctxt) {
    if (this.down) {
      ctxt.fillStyle = this.down_color;
    } else {
      ctxt.fillStyle = this.up_color;
    }
    ctxt.fillRect( this.corner_x, this.corner_y, this.width, this.height );
  }
  event_in_button ( event ) {
    let coords = this.get_corrected_coords ( event );
    if ( (coords[0] >= this.corner_x) && (coords[0] <= (this.corner_x + this.width)) ) {
      if ( (coords[1] >= this.corner_y) && (coords[1] <= (this.corner_y + this.height)) ) {
        return ( true );
      }
    }
    return ( false );
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = true;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
    if (this.event_in_button(event)) {
      this.down = false;
      update_canvas();
      this.up_action ( event );
    }
  }
  down_action ( event ) {
    // Implement in subclasses
    // console.log ( "Button " + this.button_name + " down" );
  }
  up_action ( event ) {
    // Implement in subclasses
    // console.log ( "Button " + this.button_name + " up" );
  }
}

class ToggleButton extends Button {
  constructor ( name, center_x, center_y, w, h ) {
    super ( name, center_x, center_y, w, h );
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = !this.down;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
  }
}


var button_list = [];

function draw_button_list ( ctxt ) {
  for (let i=0; i<button_list.length; i++) {
    button_list[i].draw(ctxt);
  }
}

function execute_button_list_down ( event ) {
  // NOTE: The clientX and clientY from the event may need correction.
  // This is handled in the button class, but not in the event itself.
  for (let i=0; i<button_list.length; i++) {
    button_list[i].mouse_down(event);
  }
}

function execute_button_list_up ( event ) {
  // NOTE: The clientX and clientY from the event may need correction.
  // This is handled in the button class, but not in the event itself.
  for (let i=0; i<button_list.length; i++) {
    button_list[i].mouse_up(event);
  }
}

class ClockStepButton extends Button { // clock_step
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    step();
    update_canvas();
  }
  up_action ( event ) {
    step();
    update_canvas();
  }
}

class ClockRunStopButton extends ToggleButton { // clock_run_stop_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    clock.mouse_down(event);
    // update_canvas();
  }
  up_action ( event ) {
    clock.mouse_up(event);
    // update_canvas();
  }
}


class ClockModule { // extends Register {

  constructor (name,nbits) {
    // super(name,nbits);
    this.clock_run_stop_button = new ClockRunStopButton ( "Clock Run/Stop", 121, 29, 20, 20, this );
    button_list.push ( this.clock_run_stop_button );
    this.clock_step_button = new ClockStepButton ( "Clock Step", 69, 32, 20, 20, this );
    button_list.push ( this.clock_step_button );
    this.nbits = nbits;
    this.reg_name = name;
    this.state = false;
    this.reset();
  }

  run() {
    this.clock_run_stop_button.down = true;
    this.state = true;
    run();
  }

  stop() {
    stop();
    this.clock_run_stop_button.down = false;
    this.state = false;
  }

  reset() {
    this.state = false;
    this.reset_button = [ [false,32,344] ];
    this.clock_speed_button = [ [2,25,16] ];
    this.clock_speeds = [ 1000, 200, 2 ];
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.position = [ 232, 6 ];
    this.radius = 5;

    // console.log ( "Update Canvas" );
    // update_canvas();
  }

  half_tick() {
    this.state = ! this.state;
  }

  get_state() {
    return ( this.state );
  }

  set_value( v ) {
    this.state = v;
  }

  get_speed_ms() {
    return ( this.clock_speed_button[0][0] );
  }

  mouse_up ( event ) {
  }

  mouse_down ( event ) {
    if ( (event.clientX >= this.reset_button[0][1]) && (event.clientX <= this.reset_button[0][1]+20) ) {
      if ( (event.clientY >= this.reset_button[0][2]) && (event.clientY <= this.reset_button[0][2]+20) ) {
        // if (consoleDebug) console.log ( "Reset down with " + event.clientX + ", " + event.clientY );
        cpu_reset();
        this.state = false;
        clock.set_value(false);
        ucode_ctr.set_value(0);
        prog_ctr.set_value(0);
        mem_addr.set_value(0);
        mem_data.set_value(0);
        inst_op.set_value(0);
        inst_data.set_value(0);
        a_reg.set_value(0);
        b_reg.set_value(0);
        sum_reg.set_value(0);
        carry_bit.set_value(0);
        zero_bit.set_value(0);
        display_out.set_value(0);
        bus.set_value(0);
        display_out.set_digits ("0");
        update_canvas();
        return;
      }
    }

    if (this.clock_run_stop_button.down) {
      run();
    } else {
      stop();
    }
    update_canvas();


    if ( (event.clientX >= this.clock_speed_button[0][1]-10) && (event.clientX <= this.clock_speed_button[0][1]+10) ) {
      if ( (event.clientY >= this.clock_speed_button[0][2]-10) && (event.clientY <= this.clock_speed_button[0][2]+10) ) {
        // if (consoleDebug) console.log ( "toggle speed button pressed" );
        for (let i=0; i<this.clock_speeds.length; i++) {
          // if (consoleDebug) console.log ( "Checking speed " + i + ": " + this.clock_speeds[i] );
          if (this.clock_speed_button[0][0] == this.clock_speeds[i]) {
            // if (consoleDebug) console.log ( "toggle speed" );
            if (i < (this.clock_speeds.length-1)) {
              this.clock_speed_button[0][0] = this.clock_speeds[i+1];
            } else {
              this.clock_speed_button[0][0] = this.clock_speeds[0];
            }
            // if (consoleDebug) console.log ( "toggled speed to " + this.clock_speed_button[0][0] );
            break;
          }
        }
        update_canvas();
      }
    }

  }

  draw(ctxt) {
    // Draw the "clock_speed_button"
    ctxt.fillStyle = "#ffffff44";
    if (this.clock_speed_button[0][0]>=1000) {
      ctxt.fillStyle = "#0000ff44";
    } else if (this.clock_speed_button[0][0]>=200) {
      ctxt.fillStyle = "#00ff0044";
    } else {
      ctxt.fillStyle = "#ff000044";
    }
    ctxt.fillRect( this.clock_speed_button[0][1]-20, this.clock_speed_button[0][2]-20, 20,20);

    // Draw the Reset "reset_button" button
    ctxt.fillStyle = "#ffffff88";
    ctxt.fillRect( this.reset_button[0][1]-10, this.reset_button[0][2]-10, 20,20);

    // Draw the Clock LED
    if (this.state) {
      ctxt.fillStyle = blue_on;
    } else {
      ctxt.fillStyle = blue_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0], this.position[1], 5, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class uCodeCounter extends Register {

  constructor (name,nbits) {
    super("uCodeCounter",nbits);
    this.state = 0;
    this.ucode_ctr_LEDs = [ [false,33,395],[false,43,395],[false,53,395] ];
    this.ucode_state_LEDs = [ [false,66,390],
                              [true,76,390],
                              [true,86,390],
                              [true,97,390],
                              [true,108,390],
                              [true,120,390] ];
    //                        [false,124,390],
    //                        [false,128,390] ];
  }

  get_value() {
    return ( this.state );
  }
  reset() {
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      this.ucode_ctr_LEDs[i][0] = false;
    }
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      this.ucode_state_LEDs[i][0] = true;
    }
    this.ucode_state_LEDs[0][0] = false;
  }

  update ( clock_state ) {
    // Update the ucode counter on the appropriate clock edge
    if (!clock_state) {
      this.ucode_ctr_LEDs[0][0] = !this.ucode_ctr_LEDs[0][0];
      if (!this.ucode_ctr_LEDs[0][0]) {
        this.ucode_ctr_LEDs[1][0] = !this.ucode_ctr_LEDs[1][0];
        if (!this.ucode_ctr_LEDs[1][0]) {
          this.ucode_ctr_LEDs[2][0] = !this.ucode_ctr_LEDs[2][0];
        }
      }
    }

    // Update the ucode state based on the counter
    this.state = 0;
    if (this.ucode_ctr_LEDs[2][0]) {
      this.state = this.state | 0x04;
    }
    if (this.ucode_ctr_LEDs[1][0]) {
      this.state = this.state | 0x02;
    }
    if (this.ucode_ctr_LEDs[0][0]) {
      this.state = this.state | 0x01;
    }
    if (this.state > 5) {
      this.state = 0;
      this.ucode_ctr_LEDs[0][0] = false;
      this.ucode_ctr_LEDs[1][0] = false;
      this.ucode_ctr_LEDs[2][0] = false;
    }
    this.ucode_state_LEDs[0][0] = true;
    this.ucode_state_LEDs[1][0] = true;
    this.ucode_state_LEDs[2][0] = true;
    this.ucode_state_LEDs[3][0] = true;
    this.ucode_state_LEDs[4][0] = true;
    this.ucode_state_LEDs[5][0] = true;
    this.ucode_state_LEDs[this.state][0] = false;

    // console.log ( "this.state before pc = " + this.state );
    return ( this.state );
  }

  draw_ucode_ctr ( ctxt ) {
    // Draw the Microcode Counter
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      if (this.ucode_ctr_LEDs[i][0]) {
        ctxt.fillStyle = red_on;
      } else {
        ctxt.fillStyle = red_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_ctr_LEDs[i][1], this.ucode_ctr_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw_ucode_state ( ctxt ) {
    // Draw the Microcode State
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      if (this.ucode_state_LEDs[i][0]) {
        ctxt.fillStyle = green_on;
      } else {
        ctxt.fillStyle = green_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_state_LEDs[i][1], this.ucode_state_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw(ctxt) {
    this.draw_ucode_ctr ( ctxt );
    this.draw_ucode_state ( ctxt );
  }
}


class ARegister extends Register {
  constructor (name,nbits) {
    super("A Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [ true, false, true, false, false, false, true, true ];
    this.position = [ [422,134],[432,134],[443,134],[453,134],[464,134],[474,134],[485,134],[495,134] ];
  }
}


class BRegister extends Register {
  constructor (name,nbits) {
    super("B Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [424,290],[434,290],[445,290],[455,290],[466,290],[477,290],[488,290],[498,290] ];
  }
}


class SumRegister extends Register {
  constructor (name,nbits) {
    super("Sum Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [368,220],[377,221],[389,221],[400,222],[409,222],[419,222],[429,222],[441,222] ];
  }
}

class CarryRegister extends Register {
  constructor (name,nbits) {
    super("Carry Bit",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [562,133] ];
  }
}

class ZeroRegister extends Register {
  constructor (name,nbits) {
    super("Zero Bit",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [572,133] ];
  }
}

class RunProgMode extends Register {
  constructor (name,nbits) {
    super("Run Mode",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [true,false];
    this.position = [ [45,111], [55,111] ];
  }
  set_value ( value ) {
    // Value will only specify one bit
    if (value == 0) {
      this.state = [false,true]
    } else {
      this.state = [true,false]
    }
  }
  draw ( ctxt ) {
    // First draw the "Run" LED
    if (this.state[0]) {
      ctxt.fillStyle = this.on_color;
    } else {
      ctxt.fillStyle = this.off_color;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0][0], this.position[0][1], this.radius, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
    // Next draw the "Program" LED (always opposite of "Run")
    if (!this.state[0]) {
      ctxt.fillStyle = red_on;
    } else {
      ctxt.fillStyle = red_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[1][0], this.position[1][1], this.radius, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class ProgramCounter extends Register {
  constructor (name,nbits) {
    super("Program Counter",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [386,6], [395,6], [404,6], [413,6] ];
  }
}


class InstructionOperation extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [true,false,false,false];
    this.position = [ [148,369], [157,370], [166,371], [177,371] ];
  }
}
class InstructionData extends Register {
  constructor (name,nbits) {
    super("Instruction Data",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,true];
    this.position = [ [187,371], [197,371], [207,371], [217,371] ];
  }
}


class MemoryAddress extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [147,145], [157,146], [166,145], [176,146] ];
  }
}

class MemoryData extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false];
    this.position = [ [138,225], [147,225], [156,225], [166,225], [176,225], [187,225], [198,225], [208,225] ];
  }
}

class BusContents extends Register {
  constructor (name,nbits) {
    super("BusContents",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false];
    this.position = [ [289,6], [298,6], [307,6], [316,6], [325,6], [334,6], [343,6], [352,6] ];
  }
}

class ControlWord extends Register {
  constructor (name,nbits) {
    super("ControlWord",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false];
    this.position = [ [366,497], [376,497], [385,497], [394,497], [403,497], [412,497], [421,497], [430,497],
                      [439,497], [448,497], [457,497], [466,497], [475,497], [484,497], [493,497], [502,497] ];
  }
}


class SevenSegmentDisplay extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.digits = "0";
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [true,true,true,true,true,true,true];
    let off = 35;
    this.position = [ [565+off,333], [578+off,332], [576+off,343], [574+off,355], [561+off,355], [563+off,343] ];
    this.segments = [ [0,1], [1,2], [2,3], [3,4], [4,5], [5,0], [2,5] ];
    this.digit_segments = [
      /* 0 */ [0,1,2,3,4,5],
      /* 1 */ [1,2],
      /* 2 */ [0,1,6,4,3],
      /* 3 */ [0,1,2,3,6],
      /* 4 */ [1,2,5,6],
      /* 5 */ [0,2,3,5,6],
      /* 6 */ [0,2,3,4,5,6],
      /* 7 */ [0,1,2],
      /* 8 */ [0,1,2,3,4,5,6],
      /* 9 */ [0,1,2,3,5,6],
    ];
  }

  set_digits ( digits ) {
    this.digits = digits;
  }

  draw_digit ( ctxt, d, offset ) {
    let segs = this.digit_segments[d];
    ctxt.strokeStyle = "#fd4a57";
    ctxt.lineWidth = 3;
    for (let i=0; i<segs.length; i++) {
      let seg = this.segments[segs[i]]
      let start = this.position[seg[0]];
      let end   = this.position[seg[1]];
      ctxt.beginPath();
      ctxt.moveTo(offset+start[0], start[1]);
      ctxt.lineTo(offset+end[0], end[1]);
      ctxt.stroke();
    }
  }

  draw(ctxt) {
    if (this.digits.length > 0) {
      for (let i=0; i<this.digits.length; i++) {
        let shft = this.digits.length - (i+1);
        let offset = -22 * shft;
        this.draw_digit ( ctxt, this.digits[i], offset );
      }
    }
  }
}


function decode ( instruction ) {
  let out = "";
  let lower = instruction & 0x0f;
  let upper = (instruction >> 4) & 0x0f;
  if (upper == 0x00) out = ( "NOP " + lower );
  if (upper == 0x01) out = ( "LDA " + lower );
  if (upper == 0x02) out = ( "ADD " + lower );
  if (upper == 0x03) out = ( "SUB " + lower );
  if (upper == 0x04) out = ( "STA " + lower );
  if (upper == 0x05) out = ( "LDI " + lower );
  if (upper == 0x06) out = ( "JMP " + lower );
  if (upper == 0x07) out = ( "JC  " + lower );
  if (upper == 0x08) out = ( "JZ  " + lower );
  if (upper == 0x09) out = ( "?09 " + lower );
  if (upper == 0x0a) out = ( "?0A " + lower );
  if (upper == 0x0b) out = ( "?0B " + lower );
  if (upper == 0x0c) out = ( "?0C " + lower );
  if (upper == 0x0d) out = ( "?0D " + lower );
  if (upper == 0x0e) out = ( "OUT " + lower );
  if (upper == 0x0f) out = ( "HLT " + lower );
  return ( out );
}

function encode ( instruction ) {
  let digits = '0123456789ABCEDF';
  let inst = instruction.replaceAll('    ',' ').replaceAll('   ',' ').replaceAll('  ',' ');
  inst = inst.toUpperCase().split(' ');
  // console.log ( "assem " + inst );
  if (digits.search(inst[0]) >= 0) {
    // console.log ( "Found addr: " + inst[0] );
    let legal   = ["NOP","LDA","ADD","SUB","STA","LDI","JMP","JC","JZ","OUT","HLT"];
    let opcodes = [ 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60,0x70,0x80, 0xE0,0xf0 ];
    let index = legal.indexOf(inst[1]);
    if (index >= 0) {
      let opcode = opcodes[index];
      if (inst.length > 2) {
        // Append the parameter
        opcode = opcode | parseInt ( inst[2], 16 );
      }
      // console.log ( "Op: " + opcode.toString(16).toUpperCase() );
      return ( opcode );
    } else if (digits.search(inst[1]) >= 0) {
      return ( digits.search(inst[1]) );
    }
  }
  return ( -1 );
}

clock = new ClockModule("Clock", 1);
run_prog_mode = new RunProgMode ("Run Mode", 2);
ucode_ctr = new uCodeCounter("uCode Counter", 3 );
prog_ctr = new ProgramCounter("Program Counter", 4);
mem_addr = new MemoryAddress("Memory Address", 4);
mem_data = new MemoryData("Memory Data", 8);
inst_op = new InstructionOperation("Instruction Op", 4);
inst_data = new InstructionData("Instruction Data", 4);
a_reg = new ARegister("Register A", 8);
b_reg = new BRegister("Register B", 8);
sum_reg = new SumRegister("Sum", 8);
carry_bit = new CarryRegister("Carry", 1);
zero_bit = new ZeroRegister("Zero", 1);
bus = new BusContents("Bus", 8);
control_word = new ControlWord("Control", 16);
display_out = new SevenSegmentDisplay("Display", 3);

micromacro = new ToggleButton ("MicroMacro", 600, 30, 20, 20);
button_list.push ( micromacro );

var image = new Image();
var image_loaded = false;

function update_canvas() {
  // console.log ( "Inside Update Canvas" );
  display_status();
  var canvas = document.getElementById('drawing_area');
  // if (consoleDebug) console.log ( "update_canvas" );
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;

    if (image_loaded) {

      // Draw the background image
      ctxt.drawImage(image,0,0);

      // Draw the modules

      // Draw the clock
      clock.draw(ctxt);

      // Draw the micro-code counter
      ucode_ctr.draw(ctxt);

      // Draw the program mode light
      run_prog_mode.draw ( ctxt );

      // Draw the Program Counter register
      prog_ctr.draw ( ctxt );

      // Draw the Bus lights
      bus.draw ( ctxt );

      // Draw the memory address and memory data registers
      mem_addr.draw ( ctxt );
      mem_data.draw ( ctxt );

      // Draw the A, B, and Sum registers
      a_reg.draw ( ctxt );
      b_reg.draw ( ctxt );
      sum_reg.draw ( ctxt );

      // Draw the flags (carry and zero)
      carry_bit.draw ( ctxt );
      zero_bit.draw ( ctxt );

      // Draw the instruction operation and data registers
      inst_op.draw ( ctxt );
      inst_data.draw ( ctxt );

      // Draw the Control Word lights
      control_word.draw ( ctxt );

      // Draw the output display
      display_out.draw ( ctxt );

      // Draw the buttons on top of everything else
      draw_button_list ( ctxt );

    }
  }
}

function setup_canvas() {
  var canvas = document.getElementById('drawing_area');
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;

    image.onload = function () {
      image_loaded = true;

      // Draw the background image
      ctxt.drawImage(image,0,0);

      update_canvas();
    };

    image.src = 'computer_background_640.png';
  }
}

function draw_canvas() {
  var drawing_area = document.getElementById ( "drawing_area" );
  if (drawing_area != null) {
    var ctxt = drawing_area.getContext("2d");
    var w = drawing_area.width;
    var h = drawing_area.height;

    image.onload = function () {
        ctxt.drawImage(image,5,5);
    };

  }
}

function mouse_up ( event ) {
  clock.mouse_up ( event );
  execute_button_list_up ( event );
}

function mouse_down ( event ) {
  clock.mouse_down ( event );
  execute_button_list_down ( event );
}

stop_running = false;
function main_loop()
{
  if (main_loop.in_main_loop)
    return;

  main_loop.in_main_loop = true;
  main_loop.bStayInLoop = false;    // by default, release main loop

  if (typeof main_loop.main_loop_counter == "undefined")
    main_loop.main_loop_counter = 0;

  if (!stop_running) {
   exec_next();
  }

  ++main_loop.main_loop_counter;

  main_loop.bStayInLoop = true;

  if (stop_running)
  main_loop.bStayInLoop = false;

  main_loop.in_main_loop = false;

  if (main_loop.bStayInLoop) {
    setTimeout ( "main_loop()", clock.get_speed_ms() ); // Call main_loop X ms from now
  }

  return main_loop.bStayInLoop;
} // main_loop

running = false;
run_counter = 1;
function run_stop() {
	running = !running;
	if (running) {
		run();
	} else {
		stop();
	}
}
function run() {
	stop_running = false;
	main_loop.main_loop_counter = 0;
	main_loop();
}
function stop() {
	running = false;
	main_loop.bStayInLoop = false;
	stop_running = true;
}
function step() {
	if (running == false) {
		exec_next();
	}
}

const HT = 0b1000000000000000; // Halt
const MI = 0b0100000000000000; // Memory Address Register In
const RI = 0b0010000000000000; // RAM In
const RO = 0b0001000000000000; // RAM Out
const IO = 0b0000100000000000; // Instruction Register Out
const II = 0b0000010000000000; // Instruction Register In
const AI = 0b0000001000000000; // A Register In
const AO = 0b0000000100000000; // A Register Out
const EO = 0b0000000010000000; // Sum Out (E looks like sigma)
const SU = 0b0000000001000000; // Subtract Signal
const BI = 0b0000000000100000; // B Register In
const OI = 0b0000000000010000; // Output Register In
const CE = 0b0000000000001000; // Program Counter Enabled
const CO = 0b0000000000000100; // Program Counter Out
const J  = 0b0000000000000010; // Jump
const FI = 0b0000000000000001; // Flags In???

const micro_bit_names = ['HT','MI','RI','RO','IO','II','AI','AO','EO','SU','BI','OI','CE','CO','J'];

/*
clock = new ClockModule("Clock", 1);
run_prog_mode = new RunProgMode ("Run Mode", 2);
ucode_ctr = new uCodeCounter("uCode Counter", 3 );
prog_ctr = new ProgramCounter("Program Counter", 4);
mem_addr = new MemoryAddress("Memory Address", 4);
mem_data = new MemoryData("Memory Data", 8);
inst_op = new InstructionOperation("Instruction Op", 4);
inst_data = new InstructionData("Instruction Data", 4);
a_reg = new ARegister("Register A", 8);
b_reg = new BRegister("Register B", 8);
sum_reg = new SumRegister("Sum", 8);
carry_bit = new CarryRegister("Carry", 1);
zero_bit = new ZeroRegister("Zero", 1);
bus = new BusContents("Bus", 8);
control_word = new ControlWord("Control", 16);
display_out = new SevenSegmentDisplay("Display", 3);
*/

var count = 0;
function exec_next() {

  // Toggle the clock
  clock.half_tick();

  if (micromacro.down) {
    // Execucte micro instructions step by step
    console.log ( "Micro" );
    ucode_ctr.update ( clock.get_state() );
    if (clock.get_state()) {
      let ucode_step = ucode_ctr.get_value();
      console.log ( "ucode step: " + ucode_step );
      if (ucode_step == 0) {
        // Always fetch
        // MI = Memory Address Register In
        // CE = Program Counter Enabled
        control_word.set_value ( MI | CE );
        let pc = prog_ctr.get_value();
        bus.set_value ( pc );
        mem_addr.set_value ( pc );
      } else if (ucode_step == 1) {
        // Always move from memory into the Instruction Register
        // RO = RAM Out
        // II = Instruction Register In
        // CE = Program Counter Enabled
        control_word.set_value ( RO | II | CE );
        let ram = memory[mem_addr.get_value()];
        bus.set_value ( ram );
        inst_op.set_value ( (ram >> 4) & 0x0f );
        inst_data.set_value ( ram & 0x0f );
        prog_ctr.set_value ( (prog_ctr.get_value() + 1) % 16 );
      } else {
        // Look at the instruction and step
        let operation = inst_op.get_value();
        let operand = inst_data.get_value();
        console.log ( "Instruction = " + operation.toString(16) + "" + operand.toString(16) );
        if (operation == 0x00)        { // "NOP " + operand );
          console.log ( "Executing NOP " + operand + " at step " + ucode_step );
          // Do nothing
          control_word.set_value ( 0 );
        } else if (operation == 0x01) { // "LDA " + operand );
          console.log ( "Executing LDA " + operand );
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
          } else if (ucode_step == 3) {
            // RO = RAM Out
            // AI = A Register In
            control_word.set_value ( RO | AI );
            bus.set_value ( memory[mem_addr.get_value()] );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x02) { // "ADD " + operand );
          console.log ( "Executing ADD " + operand );
        } else if (operation == 0x03) { // "SUB " + operand );
          console.log ( "Executing SUB " + operand );
        } else if (operation == 0x04) { // "STA " + operand );
          console.log ( "Executing STA " + operand );
        } else if (operation == 0x05) { // "LDI " + operand );
          console.log ( "Executing LDI " + operand );
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // AI = A Register In
            control_word.set_value ( IO | AI );
            bus.set_value ( inst_data.get_value() );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x06) { // "JMP " + operand );
          console.log ( "Executing JMP " + operand );
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // J  = Jump
            control_word.set_value ( IO | J );
            bus.set_value ( inst_data.get_value() );
            prog_ctr.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x07) { // "JC  " + operand );
          console.log ( "Executing JC " + operand );
        } else if (operation == 0x08) { // "JZ  " + operand );
          console.log ( "Executing JZ " + operand );
        } else if (operation == 0x09) { // "?09 " + operand );
          console.log ( "Executing ?9 " + operand );
        } else if (operation == 0x0a) { // "?0A " + operand );
          console.log ( "Executing ?A " + operand );
        } else if (operation == 0x0b) { // "?0B " + operand );
          console.log ( "Executing ?B " + operand );
        } else if (operation == 0x0c) { // "?0C " + operand );
          console.log ( "Executing ?C " + operand );
        } else if (operation == 0x0d) { // "?0D " + operand );
          console.log ( "Executing ?D " + operand );
        } else if (operation == 0x0e) { // "OUT " + operand );
          console.log ( "Executing OUT " + operand );
          if (ucode_step == 2) {
            // AO = A Register Out
            // OI = Output Register In
            control_word.set_value ( AO | OI );
            bus.set_value ( a_reg.get_value() );
            display_out.set_value ( bus.get_value() );
            display_out.set_digits ( String(bus.get_value()) );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x0f) { // "FX" Halt instruction ("HLT")
          console.log ( "Executing HLT " + operand );
          control_word.set_value ( HT );
          clock.stop();
          stop();
        }
      }
    } else {
      // This is the alternate half of the clock cycle
    }
  } else {
    // Execute macro instructions
    console.log ( "Macro" );
    // Update the ucode counter
    ucode_ctr.update ( clock.get_state() );

    if ( clock.get_state() && (ucode_ctr.get_state() == 3) ) {
      // Execute the current instruction
      let pc = prog_ctr.get_value();
      if (consoleDebug) console.log ( "Execute " + hex2(memory[pc]) + " = " + decode(memory[pc]) );

      mem_addr.set_value ( pc );
      mem_data.set_value ( memory[pc] );
      let lower = memory[pc] & 0x0f;
      let upper = (memory[pc] >> 4) & 0x0f;

      inst_op.set_value ( upper );
      inst_data.set_value ( lower );

      if (upper == 0x00)        { // "NOP " + lower );
        // Do nothing
      } else if (upper == 0x01) { // "LDA " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        if (consoleDebug) console.log ( "  A = memory[" + lower + "] = " + memory[lower] );
        let value = memory[lower];
        a_reg.set_value ( value );
        sum_reg.set_value ( (a_reg.get_value() + b_reg.get_value()) );
      } else if (upper == 0x02) { // "ADD " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        if (consoleDebug) console.log ( "  B = memory[" + lower + "] = " + memory[lower] );
        let value = memory[lower];
        b_reg.set_value ( value );
        let result = a_reg.get_value() + b_reg.get_value();
        if (result > 0xff) {
          carry_bit.set_value ( 1 );
        } else {
          carry_bit.set_value ( 0 );
        }
        result = result & 0xff;
        sum_reg.set_value ( result );
        a_reg.set_value ( result );
      } else if (upper == 0x03) { // "SUB " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        if (consoleDebug) console.log ( "  B = memory[" + lower + "] = " + memory[lower] );
        let value = memory[lower];
        b_reg.set_value ( value );
        sum_reg.set_value ( a_reg.get_value() - b_reg.get_value() );
        a_reg.set_value ( sum_reg.get_value() );
      } else if (upper == 0x04) { // "STA " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        memory[lower] = a_reg.get_value();
        sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
      } else if (upper == 0x05) { // "LDI " + lower );
        if (consoleDebug) console.log ( "  A = " + lower );
        a_reg.set_value ( lower );
        sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
      } else if (upper == 0x06) { // "JMP " + lower );
        mem_addr.set_value ( lower );
        if (consoleDebug) console.log ( "  JMP " + lower );
        let value = memory[lower];
        mem_data.set_value ( memory[lower] );
        pc = lower - 1; // Jump before destination since pc will be incremented
      } else if (upper == 0x07) { // "JC  " + lower );
        if (carry_bit.get_value() != 0) {
          mem_addr.set_value ( lower );
          mem_data.set_value ( memory[lower] );
          let value = memory[lower];
          pc = lower - 1; // Jump before destination since pc will be incremented
        }
      } else if (upper == 0x08) { // "JZ  " + lower );
      } else if (upper == 0x09) { // "?09 " + lower );
      } else if (upper == 0x0a) { // "?0A " + lower );
      } else if (upper == 0x0b) { // "?0B " + lower );
      } else if (upper == 0x0c) { // "?0C " + lower );
      } else if (upper == 0x0d) { // "?0D " + lower );
      } else if (upper == 0x0e) { // "OUT " + lower );
        // Display the A Register as output
        console.log ( "Out = " + a_reg.get_value() );
        display_out.set_digits ( String(a_reg.get_value()) );
      } else if (upper == 0x0f) { // "FX" Halt instruction ("HLT")
        clock.stop();
        stop();
      }
      bus.randomize_bits();
      control_word.randomize_bits();
      // Increment the program counter as needed
      pc = (pc + 1) % 16;
      prog_ctr.set_value ( pc );
    }
  }

  // Update the canvas to cause a redraw of all changes

  update_canvas();

	count = count + 1;
}

function cpu_reset() {
	is_idle = false;
	running = true;
	stop_running = true;
	run_stop();
	stop();
	run_counter = 1;
	main_loop.main_loop_counter = 0;
	ucode_ctr.reset();
	update_canvas();
}

function reset_and_run() {
  cpu_reset();
  clock.reset();
  clock.run();
}

function run_stop_callback() {
	running = !running;
	if (running) {
		document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
		document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
		run();
	} else {
		document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
		document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
		stop();
	}
}

window.onload = setup_canvas;

setup_canvas();

</script>

</head>

<body id='page' onload="setup_canvas()" onresize="update_canvas()" bgcolor="lightblue">

<table>

<tr>

<td>
<canvas id="drawing_area" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)"></canvas>
</td>

<td id="status_area" style="border: none;" valign="top">
<center>
Processor<br/>
<button type="button" onclick="run_stop_callback();" id="RunStop" style="background-color: #99FF99;">Run/<u>Stop</u></button>
<button type="button" onclick="reset_and_run()">Reset</button>

</center>
<!-- <pre>-----------------</pre> -->
<pre id="next_instruction">Next goes here.
</pre>
<p></p>
<pre id="mem_status">Memory goes here.
</pre>
<!--
<p></p>
&nbsp;<input type="checkbox" id="debug" checked onclick="toggle_debug();">Debug</input>
-->
</td>

<td style="border: none;" valign="top">
<center>
Hex Code<br/>
<button type="button" onclick="load_hex()">Load</button><br/>
<textarea id="Hex Code" rows="20" cols="12"></textarea><br/>
</center>
</td>

<td style="border: none;" valign="top">
<center>
Source Code<br/>
<button type="button" onclick="assemble()">Assemble</button><br/>
<textarea id="Source Code" rows="20" cols="12"></textarea>
<br/>
<select id="examples" onchange="change_example()">
<option value="Examples">Examples</option>
<option value="No Ops">No Ops</option>
<option value="All Legal">All Legal</option>
<option value="All Ops">All Ops</option>
<option value="Test LDA">Test LDA</option>
<option value="Test LDI">Test LDI</option>
<option value="Test JMP">Test JMP</option>
<option value="Test OUT">Test OUT</option>
<option value="Counter">Counter</option>
<option value="Add Halt">Add Halt</option>
<option value="Fibonacci">Fibonacci</option>
<!-- <option value="Multiply">Multiply: E x F</option> May not work yet -->
</select>
</center>
</td>

</tr>
</table>


<hr/>
<center>
Instruction Set (a=address, v=value, x=don't care)
<hr/>
<table>
<tr><td><b>Name</b></td><td><b>Hex</b></td><td><b>Binary</b></td><td><b>Description</b></td></tr>
<tr><td>NOP</td><td>0x</td><td>0000 xxxx</td><td>No operation (does nothing)</td></tr>
<tr><td>LDA</td><td>1a</td><td>0001 addr</td><td>Load from memory (addr) into A Register</td></tr>
<tr><td>ADD</td><td>2a</td><td>0010 addr</td><td>Add from memory (addr) into A Register</td></tr>
<tr><td>SUB</td><td>3a</td><td>0011 addr</td><td>Subtract memory (addr) from A Register</td></tr>
<tr><td>STA</td><td>4a</td><td>0100 addr</td><td>Store to memory (addr) from A Register</td></tr>
<tr><td>LDI</td><td>5v</td><td>0101 value</td><td>Load immediate value into A Register</td></tr>
<tr><td>JMP</td><td>6a</td><td>0110 addr</td><td>Jump immediate</td></tr>
<tr><td>JC </td><td>7a</td><td>0111 addr</td><td>Jump on carry immediate</td></tr>
<tr><td>JZ </td><td>8a</td><td>1000 addr</td><td>Jump on zero immediate</td></tr>
<tr><td>---</td><td>9?</td><td>1001 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>A?</td><td>1010 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>B?</td><td>1011 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>C?</td><td>1100 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>D?</td><td>1101 ???? </td><td>Not defined</td></tr>
<tr><td>OUT</td><td>Ex</td><td>1110 xxxx</td><td>Output to LED panel (could use XXXX for In/Out channels)</td></tr>
<tr><td>HLT</td><td>Fx</td><td>1111 xxxx</td><td>Halt (could use XXXX for other instructions, push, pop, chs, etc.)</td></tr>
</table>
</center>
<!--
<hr/>
Examples:
<pre>
Instruction set:
NOP = 0000 XXXX
LDA = 0001 addr
ADD = 0010 addr
SUB = 0011 addr
STA = 0100 addr
LDI = 0101 value
JMP = 0110 addr
JC  = 0111 addr
JZ  = 1000 addr
    = 1001
    = 1010
    = 1011
    = 1100
    = 1101
OUT = 1110 XXXX  // Could use XXXX for In/Out and multiple channels
HLT = 1111 XXXX  // Could use XXXX for other instructions, push, pop, chs, etc.

//var memory = [
//* 0 */ 0x1e,  // LDA E (ff)
//* 1 */ 0x55,  // LDI 5
//* 2 */ 0x2f,  // ADD F 5
//* 3 */ 0x3d,  // SUB F 1
//* 4 */ 0xf0,  // HLT
//* 5 */ 0x60,  // JMP 0
//* 6 */ 0x00,
//* 7 */ 0x00,
//* 8 */ 0x00,
//* 9 */ 0x00,
//* a */ 0x00,
//* b */ 0x00,
//* c */ 0x00,
//* d */ 0x01,
//* e */ 0xff,
//* f */ 0x05,
//];

/* Program to shift A along (works)
  0x18,
  0x19,
  0x1a,
  0x1b,
  0x1c,
  0x1d,
  0x1e,
  0x60, // Jump 0
  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80
*/

/*
// Program to shift A to the left
  0x18,  // 00: LDA 14
  0x19,
  0x1a,
  0x1b,
  0x1c,
  0x1d,
  0x1e,
  0x1f,

  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80
*/

</pre>
-->
</body>
</html>

