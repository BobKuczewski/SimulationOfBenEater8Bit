<!DOCTYPE html>

<html>

<head>
<title>Ben Eater's 8-bit Computer: Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<script>
debugging = false;

var memory = [ // Fibonacci Numbers up to 233
/* 0 */ 0x51,  // ldi 1   ; 1
/* 1 */ 0x4e,  // sta e   ; y(e) = 1
/* 2 */ 0x50,  // ldi 0   ; x = 0
/* 3 */ 0x2e,  // add [e] ; x + y
/* 4 */ 0x4f,  // sta [f] ; z = x + y
/* 5 */ 0x1e,  // lda [e] ; y
/* 6 */ 0x4d,  // sta [d] ; x = y
/* 7 */ 0x1f,  // lda [f] ; z
/* 8 */ 0x4e,  // sta [e] ; y = z
/* 9 */ 0x1d,  // lda [d] ; x
/* a */ 0xe0,  // out
/* b */ 0x70,  // jc  0   ; jump carry to next Fib
/* c */ 0x63,  // jmp 3   ; keep adding
/* d */ 0x00,  // x
/* e */ 0x00,  // y
/* f */ 0x00,  // z
];


function hex1 ( v ) {
	return ( (v % 16).toString(16).toUpperCase() );
}

function hex2 ( v ) {
	let h = (v % 256).toString(16).toUpperCase();
	while (h.length < 2) {
		h = "0" + h;
	}
	return ( h );
}

function hex4 ( v ) {
	let h = (v % 65536).toString(16).toUpperCase();
	while (h.length < 4) {
		h = "0" + h;
	}
	return ( h );
}

function bin1 ( v ) {
	return ( (v % 2).toString(2) );
}

function bin2 ( v ) {
	let b = (v % 4).toString(2);
	while (b.length < 2) {
		b = "0" + b;
	}
	return ( b );
}

function bin3 ( v ) {
	let b = (v % 8).toString(2);
	while (b.length < 3) {
		b = "0" + b;
	}
	return ( b );
}

function bin4 ( v ) {
	let b = (v % 16).toString(2);
	while (b.length < 4) {
		b = "0" + b;
	}
	return ( b );
}

function display_status() {
  let txt = "";
  let next_instr = document.getElementById('next_instruction');
  let npc = prog_ctr.get_value();
  let no = memory[npc];
  txt = " Next:\n  " + hex1(npc) + ":" + hex2(no) + " " + decode(no) + "\n";
  next_instr.innerHTML = txt;

  let mem_disp = document.getElementById('mem_status');
  txt = " Memory:\n";
  for (let i=0; i<memory.length; i++) {
    let p = "";
    // if (i == npc) {
    if (i == ucode_ctr.last_pc) {
      p = " <<---";
    }
    txt = txt + "  " + hex1(i) + " " + hex2(memory[i]) + p + "\n";
  }
  mem_disp.innerHTML = txt;
}

function single_spaces ( s ) {
  let ss = s.trim();
  while (ss.indexOf('  ') >= 0) {
    ss = ss.replaceAll('  ',' ');
  }
  return ( ss );
}


function load_hex() {
  let hex = document.getElementById("Hex Code").value;
  hex = single_spaces ( hex );
  if (hex.length > 0) {
    let hex_list = hex.trim().replaceAll('\n',' ').replace('  ',' ').split(' ');
    for (let i=0; i<hex_list.length; i++) {
      hex_list[i] = parseInt ( hex_list[i], 16 );
    }
    memory = hex_list;
    while (memory.length < 16) {
      memory.push(0);
    }
  }
  update_canvas();
}

function zero_hex() {
  let hex_code = "00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n00\n";
  document.getElementById("Hex Code").value = hex_code;
  update_canvas();
}


function assemble() {
  let asm = document.getElementById("Source Code").value;
  let asm_list = asm.trim().replaceAll('\r','\n').split('\n');
  let instr_list = [];
  // Remove empty lines
  for (let i=0; i<asm_list.length; i++) {
    if (asm_list[i].trim().length > 0) {
      instr_list.push ( asm_list[i].trim() );
    }
  }
  // Condense any multiple spaces down to a single space
  for (let i=0; i<instr_list.length; i++) {
    instr_list[i] = single_spaces ( instr_list[i] );
  }
  // Begin generating the hex code
  let hex_code = "";
  for (let i=0; i<instr_list.length; i++) {
    // Encode the instruction into an integer
    let opcode = encode ( instr_list[i] );
    // Convert the integer into a 2 digit hex value
    if (opcode >= 0) {
      hex_code = hex_code + hex2(opcode) + "\n";
    }
  }
  document.getElementById("Hex Code").value = hex_code;
}

function change_example() {
  if (document.getElementById("examples").value == "Examples") {
    document.getElementById("Source Code").value = "";
  } else if (document.getElementById("examples").value == "NOP HLT") {
    document.getElementById("Source Code").value = "0 NOP\n1 HLT\n";
  } else if (document.getElementById("examples").value == "Add Sub") {
    document.getElementById("Source Code").value =
      "0 ldi 0\n1 add 9\n2 sub 9\n3 add 8\n4 sub 7\n5 sub 9\n6 hlt\n" +
      "7 7\n8 8\n9 9\nA a\nB b\nC c\nD d\nE e\nF f\n";
  } else if (document.getElementById("examples").value == "Line Nums") {
    document.getElementById("Source Code").value =
      "0 \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \nA \nB \nC \nD \nE \nF \n";
  } else if (document.getElementById("examples").value == "Counter") {
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 STA F\n2 LDI 0\n3 ADD F\n4 OUT\n5 JMP 3\n";
  } else if (document.getElementById("examples").value == "Fibonacci") {
    document.getElementById("Source Code").value =
      "0 LDI 1\n1 STA E\n2 LDI 0\n3 ADD E\n4 STA F\n5 LDA E\n6 STA D\n7 LDA F\n" +
      "8 STA E\n9 LDA D\nA OUT\nB JC 0\nC JMP 3\nD 0\nE 0\nF 0\n";
  } else if (document.getElementById("examples").value == "CountUpDown") {
    document.getElementById("Source Code").value =
      "0 out\n1 add f\n2 jc 4\n3 jmp 0\n4 sub f\n5 out\n6 jz 0\n7 jmp 4\n" +
      "8 0\n9 0\na 0\nb 0\nc 0\nd 0\ne 0\nf 5\n";
  } else if (document.getElementById("examples").value == "Add 14+28") {
    document.getElementById("Source Code").value =
      "0 lda 4\n1 add 5\n2 out\n3 hlt\n4 0e\n5 1c\n6 0\n7 0\n" +
      "8 0\n9 0\na 0\nb 0\nc 0\nd 0\ne 0\nf 1\n";
  } else if (document.getElementById("examples").value == "Mult 3x5") {
    document.getElementById("Source Code").value =
      "0 lda e\n1 sub c\n2 jc 6\n3 lda d\n4 out\n5 hlt\n6 sta e\n7 lda d\n" +
      "8 add f\n9 sta d\na jmp 0\nb 0\nc 1\nd 0\ne 3 ; Multiply this\nf 5 ; by this\n";
  } else if (document.getElementById("examples").value == "Mult 7x8") {
    document.getElementById("Source Code").value =
      "0 LDA E\n1 SUB C\n2 JC 6\n3 LDA D\n4 OUT\n5 HLT\n6 STA E\n7 LDA D\n" +
      "8 ADD F\n9 STA D\nA JMP 0\nB 0\nC 1\nD 0\nE 7 ; Multiply this\nF 8 ; by this\n"
  } else if (document.getElementById("examples").value == "Mult 15x15") {
    document.getElementById("Source Code").value =
      "0 LDA E\n" +
      "1 SUB C\n" +
      "2 JC 6\n" +
      "3 LDA D\n" +
      "4 OUT\n" +
      "5 HLT\n" +
      "6 STA E\n" +
      "7 LDA D\n" +
      "8 ADD F\n" +
      "9 STA D\n" +
      "A JMP 0\n" +
      "B 0\n" +
      "C 1\n" +
      "D 0\n" +
      "E F ; Multiply this\n" +
      "F F ; by this\n"
  }
  display_status();
  update_canvas();
}

function toggle_debugging() {
  debugging = document.getElementById("Debugging").checked;
  if (debugging) {
    console.log ( "Debugging Enabled" );
  } else {
    console.log ( "Debugging Disabled" );
  }
  update_canvas();
}

var gray_on = "#cccccc";
var gray_off = "#444444";
var red_on = "#ff6060";
var red_off = "#880000";
var yellow_on = "#ffff00";
var yellow_off = "#705010";
var blue_on = "#bbccff";
var blue_off = "#304090";
var green_on = "#80ff08";
var green_off = "#185621";

class Register {
  constructor ( name, nbits ) {
    this.nbits = nbits;
    this.reg_name = name;
    this.on_color = gray_on;
    this.off_color = gray_off;
    this.radius = 10;
    this.state = [ true ];
    this.position = [ [20,90] ];
  }
  get_state() {
    return ( this.state );
  }
  get_bit ( index ) {
    if ((index >= 0) && (index < this.state.length)) {
      return ( this.state[index] );
    } else {
      return ( null );
    }
  }
  get_value() {
    let value = 0;
    let n = this.state.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      if (this.state[i]) {
        value = value | (0x01 << bit);
      }
      bit = bit - 1;
    }
    value = value & ((2**this.nbits)-1);
    return ( value );
  }
  set_value ( value ) {
    // The register indexes are bit positions, so reverse
    // value = 1101  gives [ 1, 0, 1, 1 ]
    value = value & ( (2 ** this.nbits) - 1 ); // Mask off any higher order bits
    this.state = [];
    let n = this.position.length;
    let bit = n-1;
    for (let i=0; i<n; i++) {
      // if ((value >> bit) & 0x01) > 0) {
      if ((value & (0x01 << bit)) > 0) {
        this.state.push ( true );
      } else {
        this.state.push ( false );
      }
      bit = bit - 1;
    }
  }
  randomize_bits () {
    for (let i=0; i<this.state.length; i++) {
      if (Math.random() > 0.5) {
        this.state[i] = true;
      } else {
        this.state[i] = false;
      }
    }
  }
  draw ( ctxt ) {
    // Draw the Register lights
    for (let i=0; i<this.position.length; i++) {
      let s = false;
      if (i < this.state.length) {
        s = this.state[i];
      }
      if (s) {
        ctxt.fillStyle = this.on_color;
      } else {
        ctxt.fillStyle = this.off_color;
      }
      ctxt.beginPath();
      ctxt.arc(this.position[i][0], this.position[i][1], this.radius, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }
  toString() {
    let s = "Register " + this.reg_name + " = " + this.get_value();
    return ( s );
  }
}


class Button {
  constructor ( name, center_x, center_y, w, h ) {
    this.button_name = name;
    this.down_color = "#ffcccc80";
    this.up_color   = "#ccccff80";
    this.down = false;
    this.center_x = center_x;
    this.center_y = center_y;
    this.width = w;
    this.height = h;
    this.corner_x = this.center_x - (this.width/2);
    this.corner_y = this.center_y - (this.height/2);
  }
  get_corrected_coords ( event ) {
    // This function is needed on browsers where offsetX and offsetY are not correct.
    let offsets = [];
    let target = event.target || event.srcElement;
    let rect = target.getBoundingClientRect();
    let offsetX = event.clientX - rect.left;
    let offsetY = event.clientY - rect.top;
    let corrected = [offsetX, offsetY];
    return corrected;
  }
  set_down() {
    this.down = true;
  }
  set_up() {
    this.down = false;
  }
  set_down_color ( color ) {
    this.down_color = color;
  }
  set_up_color ( color ) {
    this.up_color = color;
  }
  draw(ctxt) {
    if (this.down) {
      ctxt.fillStyle = this.down_color;
    } else {
      ctxt.fillStyle = this.up_color;
    }
    ctxt.fillRect( this.corner_x, this.corner_y, this.width, this.height );
  }
  event_in_button ( event ) {
    let coords = this.get_corrected_coords ( event );
    if ( (coords[0] >= this.corner_x) && (coords[0] <= (this.corner_x + this.width)) ) {
      if ( (coords[1] >= this.corner_y) && (coords[1] <= (this.corner_y + this.height)) ) {
        return ( true );
      }
    }
    return ( false );
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = true;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
    if (this.event_in_button(event)) {
      this.down = false;
      update_canvas();
      this.up_action ( event );
    }
  }
  down_action ( event ) {
    // Implement in subclasses
  }
  up_action ( event ) {
    // Implement in subclasses
  }
}

class ToggleButton extends Button {
  constructor ( name, center_x, center_y, w, h ) {
    super ( name, center_x, center_y, w, h );
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = !this.down;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
  }
}


class DIPSwitch extends ToggleButton {
  constructor ( name, center_x, center_y, w, h ) {
    super ( name, center_x, center_y, w, h );
    this.down_color = "#ffffff";
    this.up_color   = "#000000";
  }
  get_value() {
    if (this.down) {
      return ( 1 );
    } else {
      return ( 0 );
    }
  }
  mouse_down ( event ) {
    if (this.event_in_button(event)) {
      this.down = !this.down;
      update_canvas();
      this.down_action ( event );
    }
  }
  mouse_up ( event ) {
  }
}

class MemDIPSwitch extends DIPSwitch {
  mouse_down ( event ) {
    super.mouse_down ( event );
    if (prog_mode_toggle.down) {
      let ma = (mem_addr_DIP_3.get_value() << 3) +
               (mem_addr_DIP_2.get_value() << 2) +
               (mem_addr_DIP_1.get_value() << 1) +
               (mem_addr_DIP_0.get_value() << 0);
      mem_addr.set_value ( ma );
      update_canvas();
    }
  }
}

var button_list = [];

function draw_button_list ( ctxt ) {
  for (let i=0; i<button_list.length; i++) {
    button_list[i].draw(ctxt);
  }
}

function execute_button_list_down ( event ) {
  // NOTE: The clientX and clientY from the event may need correction.
  // This is handled in the button class, but not in the event itself.
  for (let i=0; i<button_list.length; i++) {
    button_list[i].mouse_down(event);
  }
}

function execute_button_list_up ( event ) {
  // NOTE: The clientX and clientY from the event may need correction.
  // This is handled in the button class, but not in the event itself.
  for (let i=0; i<button_list.length; i++) {
    button_list[i].mouse_up(event);
  }
}

class ClockStepButton extends Button { // clock_step
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    step();
    update_canvas();
  }
  up_action ( event ) {
    step();
    update_canvas();
  }
}

class ClockRunStopButton extends ToggleButton { // clock_run_stop_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    clock.mouse_down(event);
  }
  up_action ( event ) {
    clock.mouse_up(event);
  }
}

class ResetButton extends Button { // reset_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  reset() {
    cpu_reset();
    this.state = false;
    clock.set_value(false);
    control_word.set_value(0);
    ucode_ctr.set_value(0);
    ucode_ctr.last_pc = 0;
    prog_ctr.set_value(0);
    mem_addr.set_value(0);
    mem_data.set_value(0);
    inst_op.set_value(0);
    inst_data.set_value(0);
    a_reg.set_value(0);
    b_reg.set_value(0);
    sum_reg.set_value(0);
    carry_bit.set_value(0);
    zero_bit.set_value(0);
    display_out.set_value(0);
    bus.set_value(0);
    display_out.set_digits ("0");
    clock.clock_run_stop_button.down = false;
    update_canvas();
  }
  down_action ( event ) {
    this.reset();
  }
  up_action ( event ) {
  }
}


class SpeedButton extends Button { // clock_speed_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
    this.clock = clock;  // This is the clock module associated with this button
  }
  down_action ( event ) {
    if (this.clock.clock_speed_index < this.clock.clock_speeds.length-1) {
      this.clock.clock_speed_index += 1;
    } else {
      this.clock.clock_speed_index = 0;
    }
    this.down_color = this.clock.clock_speed_colors[this.clock.clock_speed_index];
    this.up_color = this.clock.clock_speed_colors[this.clock.clock_speed_index];
    update_canvas();
  }
  up_action ( event ) {
  }
}


class ClockModule { // extends Register {

  constructor (name,nbits) {
    // super(name,nbits);
    this.clock_speeds       = [ 1000,        100,         10,          1          ]; // Actually clock intervals in milliseconds
    this.clock_speed_colors = [ "#0000ff44", "#00ff0044", "#dddd0044", "#ff000044"];
    this.clock_speed_index = this.clock_speeds.length-1;

    this.clock_run_stop_button = new ClockRunStopButton ( "Clock Run/Stop", 121,29, 20,20, this );
    button_list.push ( this.clock_run_stop_button );

    this.clock_step_button = new ClockStepButton ( "Clock Step", 71,34, 20,20, this );
    button_list.push ( this.clock_step_button );

    this.reset_button = new ResetButton ( "Reset", 32,343, 20,20, this );
    button_list.push ( this.reset_button );

    this.speed_button = new SpeedButton ( "Clock Speed", 19,10, 20,20, this );
    this.speed_button.up_color   = this.clock_speed_colors[this.clock_speed_index];
    this.speed_button.down_color = this.clock_speed_colors[this.clock_speed_index];
    button_list.push ( this.speed_button );

    this.nbits = nbits;
    this.reg_name = name;
    this.state = false;
    this.reset();
  }

  run() {
    this.clock_run_stop_button.down = true;
    this.state = true;
    run();
  }

  stop() {
    this.clock_run_stop_button.down = false;
    this.state = false;
    stop();
  }

  reset() {
    this.state = false;
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.position = [ 232, 6 ];
    this.radius = 5;
  }

  half_tick() {
    this.state = ! this.state;
  }

  get_state() {
    return ( this.state );
  }

  set_value( v ) {
    this.state = v;
  }

  get_speed_ms() {
    return ( this.clock_speeds[this.clock_speed_index] );
  }

  mouse_up ( event ) {
  }

  mouse_down ( event ) {
    if (this.clock_run_stop_button.down) {
      run();
    } else {
      stop();
    }
    update_canvas();
  }

  draw(ctxt) {
    // Draw the Clock LED
    if (this.state) {
      ctxt.fillStyle = blue_on;
    } else {
      ctxt.fillStyle = blue_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0], this.position[1], 5, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class uCodeCounter extends Register {

  constructor (name,nbits) {
    super("uCodeCounter",nbits);
    this.state = 0;
    this.ucode_ctr_LEDs = [ [false,33,395],[false,43,395],[false,53,395] ];
    this.ucode_state_LEDs = [ [false,66,390],
                              [true,76,390],
                              [true,86,390],
                              [true,97,390],
                              [true,108,390],
                              [true,120,390] ];
    this.last_pc = 0;
  }

  get_value() {
    return ( this.state );
  }
  reset() {
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      this.ucode_ctr_LEDs[i][0] = false;
    }
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      this.ucode_state_LEDs[i][0] = true;
    }
    this.ucode_state_LEDs[0][0] = false;
  }

  update ( clock_state ) {
    // Update the ucode counter on the appropriate clock edge
    if (!clock_state) {
      this.ucode_ctr_LEDs[0][0] = !this.ucode_ctr_LEDs[0][0];
      if (!this.ucode_ctr_LEDs[0][0]) {
        this.ucode_ctr_LEDs[1][0] = !this.ucode_ctr_LEDs[1][0];
        if (!this.ucode_ctr_LEDs[1][0]) {
          this.ucode_ctr_LEDs[2][0] = !this.ucode_ctr_LEDs[2][0];
        }
      }
    }

    // Update the ucode state based on the counter
    this.state = 0;
    if (this.ucode_ctr_LEDs[2][0]) {
      this.state = this.state | 0x04;
    }
    if (this.ucode_ctr_LEDs[1][0]) {
      this.state = this.state | 0x02;
    }
    if (this.ucode_ctr_LEDs[0][0]) {
      this.state = this.state | 0x01;
    }
    if (this.state > 5) {
      this.state = 0;
      this.ucode_ctr_LEDs[0][0] = false;
      this.ucode_ctr_LEDs[1][0] = false;
      this.ucode_ctr_LEDs[2][0] = false;
    }
    this.ucode_state_LEDs[0][0] = true;
    this.ucode_state_LEDs[1][0] = true;
    this.ucode_state_LEDs[2][0] = true;
    this.ucode_state_LEDs[3][0] = true;
    this.ucode_state_LEDs[4][0] = true;
    this.ucode_state_LEDs[5][0] = true;
    this.ucode_state_LEDs[this.state][0] = false;

    if (this.state == 0) {
      // Store the last PC (mostly used for display)
      this.last_pc = prog_ctr.get_value();
    }

    return ( this.state );
  }

  draw_ucode_ctr ( ctxt ) {
    // Draw the Microcode Counter
    for (let i=0; i<this.ucode_ctr_LEDs.length; i++) {
      if (this.ucode_ctr_LEDs[i][0]) {
        ctxt.fillStyle = red_on;
      } else {
        ctxt.fillStyle = red_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_ctr_LEDs[i][1], this.ucode_ctr_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw_ucode_state ( ctxt ) {
    // Draw the Microcode State
    for (let i=0; i<this.ucode_state_LEDs.length; i++) {
      if (this.ucode_state_LEDs[i][0]) {
        ctxt.fillStyle = green_on;
      } else {
        ctxt.fillStyle = green_off;
      }
      ctxt.beginPath();
      ctxt.arc(this.ucode_state_LEDs[i][1], this.ucode_state_LEDs[i][2], 5, 0, 2 * Math.PI);
      ctxt.fill();
      ctxt.closePath();
    }
  }

  draw(ctxt) {
    this.draw_ucode_ctr ( ctxt );
    this.draw_ucode_state ( ctxt );
  }
}


class ARegister extends Register {
  constructor (name,nbits) {
    super("A Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [ true, false, true, false, false, false, true, true ];
    this.position = [ [422,134],[432,134],[443,134],[453,134],[464,134],[474,134],[485,134],[495,134] ];
  }
  /*
  set_value ( value ) {
    super.set_value ( value );
    sum_reg.update_sum();
  }
  */
}

class BRegister extends Register {
  constructor (name,nbits) {
    super("B Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [424,290],[434,290],[445,290],[455,290],[466,290],[477,290],[488,290],[498,290] ];
    this.sum_register = null;
  }
  /*
  set_value ( value ) {
    super.set_value ( value );
    sum_reg.update_sum();
  }
  */
}

class SumRegister extends Register {
  constructor (name,nbits) {
    super("Sum Register",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [false,true,false,true,false,true,false,true];
    this.position = [ [368,220],[377,221],[389,221],[400,222],[409,222],[419,222],[429,222],[441,222] ];
    this.a_register = null;
    this.b_register = null;
  }
  update_sum() {
    console_log ( "CW[SU] = " + control_word.state[iSU] );
    if (control_word.state[iSU]) {
      console_log ( "Subtracting" );
      // Subtract
      let result = a_reg.get_value() - b_reg.get_value();
      if (result >= 0x00) {
        carry_bit.set_value ( 1 );
      } else {
        carry_bit.set_value ( 0 );
      }
      if (result == 0) {
        zero_bit.set_value ( 1 );
      } else {
        zero_bit.set_value ( 0 );
      }
      result = result & 0xff;
      this.set_value ( result );
      // a_reg.set_value ( bus.get_value() );
    } else {
      console_log ( "Adding" );
      // Add
      let result = a_reg.get_value() + b_reg.get_value();
      if (result > 0xff) {
        carry_bit.set_value ( 1 );
      } else {
        carry_bit.set_value ( 0 );
      }
      if (result == 0) {
        zero_bit.set_value ( 1 );
      } else {
        zero_bit.set_value ( 0 );
      }
      result = result & 0xff;
      this.set_value ( result );
      // a_reg.set_value ( bus.get_value() );
    }
    /*
    } else if (operation == 0x02) { // "ADD " + operand );
      } else if (ucode_step == 4) {
        // AI = A Register In
        // EO = Sum Out (E looks like sigma)
        // FI = Flags In
        console_log ( "Add put in A" );
        control_word.set_value ( AI | EO | FI );
        let result = a_reg.get_value() + b_reg.get_value();
        if (result > 0xff) {
          carry_bit.set_value ( 1 );
        } else {
          carry_bit.set_value ( 0 );
        }
        if (result == 0) {
          zero_bit.set_value ( 1 );
        } else {
          zero_bit.set_value ( 0 );
        }
        result = result & 0xff;
        sum_reg.set_value ( result );
        bus.set_value ( result );
        a_reg.set_value ( bus.get_value() );
      } else {
        control_word.set_value ( 0 );
      }
    } else if (operation == 0x03) { // "SUB " + operand );
      } else if (ucode_step == 4) {
        // AI = A Register In
        // EO = Sum Out (E looks like sigma)
        // FI = Flags In
        // SU = Subtract Signal
        console_log ( "Subtract put in A" );
        control_word.set_value ( AI | EO | FI | SU );
        let result = a_reg.get_value() - b_reg.get_value();
        if (result >= 0x00) {
          carry_bit.set_value ( 1 );
        } else {
          carry_bit.set_value ( 0 );
        }
        if (result == 0) {
          zero_bit.set_value ( 1 );
        } else {
          zero_bit.set_value ( 0 );
        }
        result = result & 0xff;
        sum_reg.set_value ( result );
        bus.set_value ( result );
        a_reg.set_value ( bus.get_value() );
      } else {
        control_word.set_value ( 0 );
      }
    } else if ...
    */
  }
}

class CarryRegister extends Register {
  constructor (name,nbits) {
    super("Carry Bit",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [562,133] ];
  }
}

class ZeroRegister extends Register {
  constructor (name,nbits) {
    super("Zero Bit",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [false];
    this.position = [ [572,133] ];
  }
}

class RunProgMode extends Register {
  constructor (name,nbits) {
    super("Run Mode",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    this.state = [true,false];
    this.position = [ [45,111], [55,111] ];
  }
  set_value ( value ) {
    // Value will only specify one bit
    if (value == 0) {
      this.state = [false,true]
    } else {
      this.state = [true,false]
    }
  }
  draw ( ctxt ) {
    // First draw the "Run" LED
    if (this.state[0]) {
      ctxt.fillStyle = this.on_color;
    } else {
      ctxt.fillStyle = this.off_color;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[0][0], this.position[0][1], this.radius, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
    // Next draw the "Program" LED (always opposite of "Run")
    if (!this.state[0]) {
      ctxt.fillStyle = red_on;
    } else {
      ctxt.fillStyle = red_off;
    }
    ctxt.beginPath();
    ctxt.arc(this.position[1][0], this.position[1][1], this.radius, 0, 2 * Math.PI);
    ctxt.fill();
    ctxt.closePath();
  }
}

class ProgModeToggle extends ToggleButton { // prog_mode_toggle
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
  }
  down_action ( event ) {
    run_prog_mode.set_value ( !this.down );
    update_canvas();
  }
  up_action ( event ) {
    run_prog_mode.set_value ( !this.down );
    update_canvas();
  }
}

class ProgramWrite extends Button { // program_write_button
  constructor ( name, center_x, center_y, w, h, clock ) {
    super ( name, center_x, center_y, w, h );
  }
  down_action ( event ) {
    if (prog_mode_toggle.down) {
      let mem_addr = (mem_addr_DIP_3.get_value() << 3) +
                     (mem_addr_DIP_2.get_value() << 2) +
                     (mem_addr_DIP_1.get_value() << 1) +
                     (mem_addr_DIP_0.get_value() << 0);
      let data_val = (data_in_DIP_7.get_value() << 7) +
                     (data_in_DIP_6.get_value() << 6) +
                     (data_in_DIP_5.get_value() << 5) +
                     (data_in_DIP_4.get_value() << 4) +
                     (data_in_DIP_3.get_value() << 3) +
                     (data_in_DIP_2.get_value() << 2) +
                     (data_in_DIP_1.get_value() << 1) +
                     (data_in_DIP_0.get_value() << 0);
      if (mem_addr < memory.length) {
        memory[mem_addr] = data_val;
        mem_data.set_value(data_val);
      }
    } else {
      console.log ( "Unable to Program in Run Mode - Toggle the Run/Load Button" );
    }
  }
}


class ProgramCounter extends Register {
  constructor (name,nbits) {
    super("Program Counter",nbits);
    this.on_color = green_on;
    this.off_color = green_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [386,6], [395,6], [404,6], [413,6] ];
  }
}


class InstructionOperation extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [true,false,false,false];
    this.position = [ [148,369], [157,370], [166,371], [177,371] ];
  }
}
class InstructionData extends Register {
  constructor (name,nbits) {
    super("Instruction Data",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,true];
    this.position = [ [187,371], [197,371], [207,371], [217,371] ];
  }
}


class MemoryData extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false];
    this.position = [ [138,225], [147,225], [156,225], [166,225], [176,225], [187,225], [198,225], [208,225] ];
  }
}


class MemoryAddress extends Register {
  constructor (name,nbits) {
    super("Memory Address",nbits);
    this.on_color = yellow_on;
    this.off_color = yellow_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false];
    this.position = [ [147,145], [157,146], [166,145], [176,146] ];
    this.data_register = null;
  }
  set_data_register ( r ) {
    this.data_register = r;
  }
  set_value ( value ) {
    super.set_value ( value );
    if (this.data_register != null) {
      // Also update the MemoryData associated with this address
      this.data_register.set_value ( memory[this.get_value()] );
    }
  }
}


class BusContents extends Register {
  constructor (name,nbits) {
    super("BusContents",nbits);
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false];
    this.position = [ [289,6], [298,6], [307,6], [316,6], [325,6], [334,6], [343,6], [352,6] ];
  }
}

class ControlWord extends Register {
  constructor (name,nbits) {
    super("ControlWord",nbits);
    this.on_color = blue_on;
    this.off_color = blue_off;
    this.radius = 5;
    // Note that index 0 corresponds to bit 0 (LSB)
    this.state = [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false];
    this.position = [ [366,497], [376,497], [385,497], [394,497], [403,497], [412,497], [421,497], [430,497],
                      [439,497], [448,497], [457,497], [466,497], [475,497], [484,497], [493,497], [502,497] ];
  }
}


class SevenSegmentDisplay extends Register {
  constructor (name,nbits) {
    super("Instruction Operation",nbits);
    this.digits = "0";
    this.on_color = red_on;
    this.off_color = red_off;
    this.radius = 5;
    this.state = [true,true,true,true,true,true,true];
    let off = 35;
    this.position = [ [565+off,333], [578+off,332], [576+off,343], [574+off,355], [561+off,355], [563+off,343] ];
    this.segments = [ [0,1], [1,2], [2,3], [3,4], [4,5], [5,0], [2,5] ];
    this.digit_segments = [
      /* 0 */ [0,1,2,3,4,5],
      /* 1 */ [1,2],
      /* 2 */ [0,1,6,4,3],
      /* 3 */ [0,1,2,3,6],
      /* 4 */ [1,2,5,6],
      /* 5 */ [0,2,3,5,6],
      /* 6 */ [0,2,3,4,5,6],
      /* 7 */ [0,1,2],
      /* 8 */ [0,1,2,3,4,5,6],
      /* 9 */ [0,1,2,3,5,6],
    ];
  }

  set_digits ( digits ) {
    this.digits = digits;
  }

  draw_digit ( ctxt, d, offset ) {
    let segs = this.digit_segments[d];
    ctxt.strokeStyle = "#fd4a57";
    ctxt.lineWidth = 3;
    for (let i=0; i<segs.length; i++) {
      let seg = this.segments[segs[i]]
      let start = this.position[seg[0]];
      let end   = this.position[seg[1]];
      ctxt.beginPath();
      ctxt.moveTo(offset+start[0], start[1]);
      ctxt.lineTo(offset+end[0], end[1]);
      ctxt.stroke();
    }
  }

  draw(ctxt) {
    if (this.digits.length > 0) {
      for (let i=0; i<this.digits.length; i++) {
        let shft = this.digits.length - (i+1);
        let offset = -22 * shft;
        this.draw_digit ( ctxt, this.digits[i], offset );
      }
    }
  }
}


class ExecModeButton extends ToggleButton {
  constructor ( name, center_x, center_y, w, h ) {
    super ( name, center_x, center_y, w, h );
    this.mode_names  = [  "macro",  "micro1",  "micro2"];
    this.mode_colors = ["#0000ff", "#00ff00", "#ff0000"];
    this.mode_index  = 1; // micro1  ...  had been micro2
    this.down_color  = this.mode_colors[this.mode_index];
    this.up_color    = this.mode_colors[this.mode_index];
    this.enabled     = false;
  }
  set_mode ( mode_name ) {
    let i = this.mode_names.indexOf(mode_name);
    if (i >= 0) {
      this.mode_index = i;
    }
    return ( i );
  }
  get_value() {
    return ( this.mode_index );
  }
  get_mode_name() {
    return ( this.mode_names[this.mode_index] );
  }
  mouse_down ( event ) {
    if (debugging) {
      if (this.event_in_button(event)) {
        console.log ( "Exec Mode change from " + this.mode_index );
        this.down = !this.down;
        this.mode_index += 1;
        if (this.mode_index >= this.mode_colors.length) {
          this.mode_index = 0;
        }
        this.down_color  = this.mode_colors[this.mode_index];
        this.up_color    = this.mode_colors[this.mode_index];
        update_canvas();
        console.log ( "  to " + this.mode_index );
      }
    }
  }
  draw(ctxt) {
    if (debugging) {
      super.draw(ctxt);
    }
  }
}


function decode ( instruction ) {
  let out = "";
  let lower = instruction & 0x0f;
  let upper = (instruction >> 4) & 0x0f;
  if (upper == 0x00) out = ( "NOP " + lower );
  if (upper == 0x01) out = ( "LDA " + lower );
  if (upper == 0x02) out = ( "ADD " + lower );
  if (upper == 0x03) out = ( "SUB " + lower );
  if (upper == 0x04) out = ( "STA " + lower );
  if (upper == 0x05) out = ( "LDI " + lower );
  if (upper == 0x06) out = ( "JMP " + lower );
  if (upper == 0x07) out = ( "JC  " + lower );
  if (upper == 0x08) out = ( "JZ  " + lower );
  if (upper == 0x09) out = ( "?09 " + lower );
  if (upper == 0x0a) out = ( "?0A " + lower );
  if (upper == 0x0b) out = ( "?0B " + lower );
  if (upper == 0x0c) out = ( "?0C " + lower );
  if (upper == 0x0d) out = ( "?0D " + lower );
  if (upper == 0x0e) out = ( "OUT " + lower );
  if (upper == 0x0f) out = ( "HLT " + lower );
  return ( out );
}

function encode ( instruction ) {
  let digits = '0123456789ABCEDF';
  let inst = single_spaces ( instruction );
  inst = inst.toUpperCase().split(' ');
  if (inst.length >= 2) {
    // Legal since all must be at least 2 (or 3)
    // Check to see if the second operand is an instruction
    let legal   = ["NOP","LDA","ADD","SUB","STA","LDI","JMP","JC","JZ","OUT","HLT"];
    let opcodes = [ 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60,0x70,0x80, 0xE0,0xf0 ];
    let index = legal.indexOf(inst[1]);
    if (index >= 0) {
      // This is an op code with an optional parameter
      let opcode = opcodes[index];
      if (inst.length > 2) {
        // Append the parameter
        opcode = opcode | parseInt ( inst[2], 16 );
      }
      return ( opcode );
    } else {
      // This must be a stored number
      if (digits.search(inst[1][0]) >= 0) {
        // This is a number
        return ( parseInt ( inst[1], 16 ) );
      } else {
        return ( -1 );
      }
    }
  }
  return ( -1 ); // Indicates an error
}


bus = new BusContents("Bus", 8);
clock = new ClockModule("Clock", 1);
run_prog_mode = new RunProgMode ("Run Mode", 2);
ucode_ctr = new uCodeCounter("uCode Counter", 3 );
prog_ctr = new ProgramCounter("Program Counter", 4);
mem_data = new MemoryData("Memory Data", 8);
mem_addr = new MemoryAddress("Memory Address", 4);
mem_addr.set_data_register(mem_data);
inst_op = new InstructionOperation("Instruction Op", 4);
inst_data = new InstructionData("Instruction Data", 4);

// Create and connect the a, b, and sum registers
sum_reg = new SumRegister("Sum", 8);
a_reg = new ARegister("Register A", 8);
// a_reg.set_sum_register ( sum_reg );
// sum_reg.set_a_register ( a_reg );
b_reg = new BRegister("Register B", 8);
// b_reg.set_sum_register ( sum_reg );
// sum_reg.set_b_register ( b_reg );

carry_bit = new CarryRegister("Carry", 1);
zero_bit = new ZeroRegister("Zero", 1);
control_word = new ControlWord("Control", 16);
display_out = new SevenSegmentDisplay("Display", 3);

prog_mode_toggle = new ProgModeToggle ( "Program Toggle", 32,108, 14,14, null );
button_list.push ( prog_mode_toggle );

program_write_button = new ProgramWrite ( "Program Write", 25,267, 20,20, null );
button_list.push ( program_write_button );

mem_addr_DIP_3 = new MemDIPSwitch ( "DIP_MA3", 70,111, 3,7, null );
button_list.push ( mem_addr_DIP_3 );
mem_addr_DIP_2 = new MemDIPSwitch ( "DIP_MA2", 74,111, 3,7, null );
button_list.push ( mem_addr_DIP_2 );
mem_addr_DIP_1 = new MemDIPSwitch ( "DIP_MA1", 79,111, 3,7, null );
button_list.push ( mem_addr_DIP_1 );
mem_addr_DIP_0 = new MemDIPSwitch ( "DIP_MA0", 83,111, 3,7, null );
button_list.push ( mem_addr_DIP_0 );

data_in_DIP_7 = new DIPSwitch ( "DIP_D7", 79,268, 3,7, null );
button_list.push ( data_in_DIP_7 );
data_in_DIP_6 = new DIPSwitch ( "DIP_D6", 83,268, 3,7, null );
button_list.push ( data_in_DIP_6 );
data_in_DIP_5 = new DIPSwitch ( "DIP_D5", 87,268, 3,7, null );
button_list.push ( data_in_DIP_5 );
data_in_DIP_4 = new DIPSwitch ( "DIP_D4", 91,268, 3,7, null );
button_list.push ( data_in_DIP_4 );
data_in_DIP_3 = new DIPSwitch ( "DIP_D3", 97,268, 3,7, null );
button_list.push ( data_in_DIP_3 );
data_in_DIP_2 = new DIPSwitch ( "DIP_D2", 101,268, 3,7, null );
button_list.push ( data_in_DIP_2 );
data_in_DIP_1 = new DIPSwitch ( "DIP_D1", 105,268, 3,7, null );
button_list.push ( data_in_DIP_1 );
data_in_DIP_0 = new DIPSwitch ( "DIP_D0", 109,268, 3,7, null );
button_list.push ( data_in_DIP_0 );

// This allows toggling between various microcode and macrocode modes.
execution_mode = new ExecModeButton ("Execution Mode", 600, 30, 20, 20);
// Comment out this instruction to hide the execution_mode button
button_list.push ( execution_mode );

var image = new Image();
var image_loaded = false;

function update_canvas() {
  display_status();
  var canvas = document.getElementById('drawing_area');
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 546;

    if (image_loaded) {

      // Draw the background image
      ctxt.drawImage(image,0,0);

      // Draw the modules

      // Draw the clock
      clock.draw(ctxt);

      // Draw the micro-code counter
      ucode_ctr.draw(ctxt);

      // Draw the program mode light
      run_prog_mode.draw ( ctxt );

      // Draw the Program Counter register
      prog_ctr.draw ( ctxt );

      // Draw the Bus lights
      bus.draw ( ctxt );

      // Draw the memory address and memory data registers
      mem_addr.draw ( ctxt );
      mem_data.draw ( ctxt );

      // Draw the A, B, and Sum registers
      a_reg.draw ( ctxt );
      b_reg.draw ( ctxt );
      sum_reg.draw ( ctxt );

      // Draw the flags (carry and zero)
      carry_bit.draw ( ctxt );
      zero_bit.draw ( ctxt );

      // Draw the instruction operation and data registers
      inst_op.draw ( ctxt );
      inst_data.draw ( ctxt );

      // Draw the Control Word lights
      control_word.draw ( ctxt );

      // Draw the output display
      display_out.draw ( ctxt );

      // Draw the buttons on top of everything else
      draw_button_list ( ctxt );

    }
  }
}

function setup_canvas() {
  var canvas = document.getElementById('drawing_area');
  if (canvas != null) {
    var ctxt = canvas.getContext('2d');
    var w = canvas.width = 640;
    var h = canvas.height = 480;

    image.onload = function () {
      image_loaded = true;

      // Draw the background image
      ctxt.drawImage(image,0,0);

      update_canvas();
    };

    image.src = 'computer_background_640.png';
  }
}

function draw_canvas() {
  var drawing_area = document.getElementById ( "drawing_area" );
  if (drawing_area != null) {
    var ctxt = drawing_area.getContext("2d");
    var w = drawing_area.width;
    var h = drawing_area.height;

    image.onload = function () {
        ctxt.drawImage(image,5,5);
    };
  }
}

function mouse_up ( event ) {
  // clock.mouse_up ( event );
  execute_button_list_up ( event );
}

function mouse_down ( event ) {
  // clock.mouse_down ( event );
  execute_button_list_down ( event );
}

stop_running = false;
function main_loop()
{
  if (main_loop.in_main_loop)
    return;

  main_loop.in_main_loop = true;
  main_loop.bStayInLoop = false;    // by default, release main loop

  if (typeof main_loop.main_loop_counter == "undefined")
    main_loop.main_loop_counter = 0;

  if (!stop_running) {
    if (clock.clock_speeds == 0) {
      // Execute multiple instructions for extra speed
      for (let i=0; i<5; i++) {
        exec_next();
      }
    } else {
      exec_next();
    }
  }

  main_loop.main_loop_counter += 1;

  main_loop.bStayInLoop = true;

  if (stop_running)
  main_loop.bStayInLoop = false;

  main_loop.in_main_loop = false;

  if (main_loop.bStayInLoop) {
    setTimeout ( "main_loop()", clock.get_speed_ms() ); // Call main_loop X ms from now
  }

  return main_loop.bStayInLoop;
}

running = false;
run_counter = 1;
function run_stop() {
	running = !running;
	if (running) {
		run();
	} else {
		stop();
	}
}
function run() {
  // Update the global buttons
  document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
	document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
  // Perform the run
	stop_running = false;
	main_loop.main_loop_counter = 0;
	main_loop();
}
function stop() {
  // Update the global buttons
	document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
	document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
  // Perform the stop
	running = false;
	main_loop.bStayInLoop = false;
	stop_running = true;
}
function step() {
	if (running == false) {
		exec_next();
	}
}

const HT = 0b1000000000000000; // Halt
const MI = 0b0100000000000000; // Memory Address Register In
const RI = 0b0010000000000000; // RAM In
const RO = 0b0001000000000000; // RAM Out
const IO = 0b0000100000000000; // Instruction Register Out
const II = 0b0000010000000000; // Instruction Register In
const AI = 0b0000001000000000; // A Register In
const AO = 0b0000000100000000; // A Register Out
const EO = 0b0000000010000000; // Sum Out (E looks like sigma)
const SU = 0b0000000001000000; // Subtract Signal
const BI = 0b0000000000100000; // B Register In
const OI = 0b0000000000010000; // Output Register In
const CE = 0b0000000000001000; // Program Counter Enabled
const CO = 0b0000000000000100; // Program Counter Out
const J  = 0b0000000000000010; // Jump
const FI = 0b0000000000000001; // Flags In???

const iFI = 15;
const iJ  = 14;
const iCO = 13;
const iCE = 12;
const iOI = 11;
const iBI = 10;
const iSU = 9;
const iEO = 8;
const iAO = 7;
const iAI = 6;
const iII = 5;
const iIO = 4;
const iRO = 3;
const iRI = 2;
const iMI = 1;
const iHT = 0;

// Note that the "I" and "O" mean "in from the bus" and "out to the bus" respectively.
const micro_bit_names = ['HT','MI','RI','RO','IO','II','AI','AO','EO','SU','BI','OI','CE','CO','J','FI'];


function console_log ( s ) {
  if (debugging) {
    console.log ( s );
  }
}

class MicroCodeMachine {
  constructor() {
    this.ucode = [
      //Inst   9 bit State   16 bit Control Word
      //                      HMRRIIAA ESBOCCJF
      //       inst stp CZ    TIIOOIIO OUIIEO I
      ["FCH", "xxxx 000 xx", "01000000 00000100"],
      ["FCH", "xxxx 001 xx", "00010100 00001000"],

      ["NOP", "0000 010 xx", "00000000 00000000"],
      ["NOP", "0000 011 xx", "00000000 00000000"],
      ["NOP", "0000 100 xx", "00000000 00000000"],

      ["LDA", "0001 010 xx", "01001000 00000000"],
      ["LDA", "0001 011 xx", "00010010 00000000"],
      ["LDA", "0001 100 xx", "00000000 00000000"],

      ["ADD", "0010 010 xx", "01001000 00000000"],
      ["ADD", "0010 011 xx", "00010000 00100000"],
      ["ADD", "0010 100 xx", "00000010 10000001"],

      ["SUB", "0011 010 xx", "01001000 00000000"], // MI IO
      ["SUB", "0011 011 xx", "00010000 00100000"], // RO BI  // Add SU here? Race?
      ["SUB", "0011 100 xx", "00000010 11000001"], // AI E0 SU FI
      // ["SUB", "0011 101 xx", "00000000 00000000"], // Attempt to keep SU active?

      ["STA", "0100 010 xx", "01001000 00000000"],
      ["STA", "0100 011 xx", "00100001 00000000"],
      ["STA", "0100 100 xx", "00000000 00000000"],

      ["LDI", "0101 010 xx", "00001010 00000000"],
      ["LDI", "0101 011 xx", "00000000 00000000"],
      ["LDI", "0101 100 xx", "00000000 00000000"],

      ["JMP", "0110 010 xx", "00001000 00000010"],
      ["JMP", "0110 011 xx", "00000000 00000000"],
      ["JMP", "0110 100 xx", "00000000 00000000"],

      ["JC",  "0111 010 0x", "00000000 00000000"],
      ["JC",  "0111 010 1x", "00001000 00000010"],
      ["JC",  "0111 011 xx", "00000000 00000000"],
      ["JC",  "0111 100 xx", "00000000 00000000"],

      ["JZ",  "1000 010 x0", "00000000 00000000"],
      ["JZ",  "1000 010 x1", "00001000 00000010"],
      ["JZ",  "1000 011 xx", "00000000 00000000"],
      ["JZ",  "1000 100 xx", "00000000 00000000"],

      ["OUT", "1110 010 xx", "00000001 00010000"],
      ["OUT", "1110 011 xx", "00000000 00000000"],
      ["OUT", "1110 100 xx", "00000000 00000000"],

      ["HLT", "1111 010 xx", "10000000 00000000"],
      ["HLT", "1111 011 xx", "00000000 00000000"],
      ["HLT", "1111 100 xx", "00000000 00000000"]
    ];
    // Remove spaces from ucode strings
    for (let i=0; i<this.ucode.length; i++) {
      this.ucode[i][1] = this.ucode[i][1].replaceAll(" ","");
      this.ucode[i][2] = this.ucode[i][2].replaceAll(" ","");
    }
  }
  matches ( example, template ) {
    // Determine if the example matches the template
    // Create a new string from the example
    let tmatch = "" + example;
    // Compare up to the common length
    let len = Math.min(example.length, tmatch.length);
    for (let i=0; i<len; i++) {
      if (template.charAt(i).toLowerCase() == 'x') {
        tmatch = tmatch.substr(0,i) + template.charAt(i) + tmatch.substring(i+1);
      }
    }
    return ( tmatch == template );
  }
  get_word_str ( ucode_addr ) {
    console_log ( "Code addr = " + ucode_addr );
    // console_log ( "get_word_str called with (" + instruction + "," + step + "," + flags + ")" );
    // let ucode_addr = instruction + step + flags;
    for (let i=0; i<this.ucode.length; i++) {
      if (this.matches(ucode_addr,this.ucode[i][1])) {
        console_log ( "Code word = " + this.ucode[i][2] );
        return ( this.ucode[i][2] );
      }
    }
    console_log ( "Code word = 0000000000000000" );
    return ( "0000000000000000" ); // Word not found for this instruction/step so do nothing

    //let ucode_entry = this.ucode[Math.trunc(Math.random()*this.ucode.length)];
    //let ucode_word = ucode_entry[2];
    // console_log ( "Code word = " + ucode_word );
    //return ( ucode_word );
  }
  exec_next() {
    console_log ( "exec_next" );
    // Do things that should happen automatically
    console_log ( "Call update_sum" );
    sum_reg.update_sum();
    mem_data.set_value ( memory[mem_addr.get_value()] );

    ucode_ctr.update ( clock.get_state() );
    if (clock.get_state()) {
      let ucode_step = ucode_ctr.get_value();
      console_log ( "executing step " + ucode_step );
      let uaddr = "";
      if (ucode_step == 0) {
        uaddr = "xxxx" + bin3(ucode_step) + "xx";
      } else if (ucode_step == 1) {
        uaddr = "xxxx" + bin3(ucode_step) + "xx";
      } else {
        // Get the instruction, carry, and zero flags:
        let inst = inst_op.get_value();
        let carry = carry_bit.get_value();
        let zero = zero_bit.get_value();
        uaddr = bin4(inst) + bin3(ucode_step) + bin1(carry) + bin1(zero);
      }
      let uword = this.get_word_str ( uaddr );
      console_log ( "uaddr = " + uaddr );
      console_log ( "uword = " + uword );
      if (uword == null) {
        console_log ( " uaddr = " + uaddr );
      } else {
        control_word.set_value ( parseInt ( uword, 2 ) );
        // Get the operations from this control word
        let operations = [];
        for (let cwbit=0; cwbit<micro_bit_names.length; cwbit++) {
          if (uword.charAt(cwbit) == 1) {
            operations.push ( micro_bit_names[cwbit] );
          }
        }
        console_log ( "Operations = " + operations );
        // Carry out the selected operations specified in this control word
        let out_cmds   = ['RO','IO','CO','AO','EO'];
        let in_cmds    = ['RI','II','MI','AI','BI','OI'];
        let other_cmds = ['HT','SU','CE','J','FI'];

        /*
        // Try to do a synchronous update by storing all inputs first
        let saved_prog_ctr = prog_ctr.get_value();
        let saved_memory = memory[mem_addr.get_value()];
        let saved_inst_data = inst_data.get_value();
        let saved_a_reg = a_reg.get_value();
        sum_reg.update_sum();
        let saved_sum_reg = sum_reg.get_value();
        */

        // Set the bus for any output commands while checking for conflicts
        // Output Commands: RO IO CO AO EO
        let already_out = false;
        let last_out = "";
        for (let i=0; i<out_cmds.length; i++) {
          if (operations.indexOf(out_cmds[i]) >= 0) {
            let cmd = out_cmds[i];
            if (!already_out) {
              // Set the bus from the desired source
              console_log ( "Set bus to " + cmd );

              if (cmd == "CO") bus.set_value ( prog_ctr.get_value() );
              if (cmd == "RO") bus.set_value ( memory[mem_addr.get_value()] );
              if (cmd == "IO") bus.set_value ( inst_data.get_value() );
              if (cmd == "AO") bus.set_value ( a_reg.get_value() );
              if (cmd == "EO") bus.set_value ( sum_reg.get_value() );
              /*
              if (cmd == "CO") bus.set_value ( saved_prog_ctr );
              if (cmd == "RO") bus.set_value ( saved_memory );
              if (cmd == "IO") bus.set_value ( saved_inst_data );
              if (cmd == "AO") bus.set_value ( saved_a_reg );
              if (cmd == "EO") bus.set_value ( saved_sum_reg );
              */

              last_out = cmd;
              already_out = true;
            } else {
              // There is contention on the bus
              console.log ( "#####################################" );
              console.log ( "  Bus contention between " + cmd + " and " + last_cmd );
              console.log ( "#####################################" );
            }
          }
        }
        // Read from the bus for any input commands
        //  Input Commands: RI II MI AI BI OI
        for (let i=0; i<in_cmds.length; i++) {
          if (operations.indexOf(in_cmds[i]) >= 0) {
            let cmd = in_cmds[i];
            // Move the value from the bus to the desired destination
            console_log ( "Move bus to " + cmd );

            if (cmd == "MI") mem_addr.set_value ( bus.get_value() );
            if (cmd == "RI") memory[mem_addr.get_value()] = bus.get_value();
            if (cmd == "AI") {
              a_reg.set_value ( bus.get_value() );
              sum_reg.update_sum();
            }
            if (cmd == "BI") {
              b_reg.set_value ( bus.get_value() );
              sum_reg.update_sum();
            }
            if (cmd == "OI") {
              display_out.set_value ( bus.get_value() );
              display_out.set_digits ( String(bus.get_value()) );
              if (debugging) {
                console.log ( "Out: " + String(bus.get_value()) );
              }
            }
            if (cmd == "II") {
              let instruction = bus.get_value();
              inst_op.set_value ( (instruction >> 4) & 0x0f );
              inst_data.set_value ( instruction & 0x0f );
            }

          }
        }
        // Perform any additional commands
        //  Additional Commands: HT SU CE J FI
        for (let i=0; i<other_cmds.length; i++) {
          if (operations.indexOf(other_cmds[i]) >= 0) {
            let cmd = other_cmds[i];
            // Carry out the operation
            console_log ( "Handle " + cmd );

            if (cmd == "HT") { /* Just a signal? */ };
            if (cmd == "CE") prog_ctr.set_value ( (prog_ctr.get_value() + 1) % 16 );
            if (cmd == "J") prog_ctr.set_value ( bus.get_value() );
            if (cmd == "SU") { /*sum_reg.update_sum();*/ /* Just a signal? */ };
            if (cmd == "FI") { /* Just a signal? */ };

          }
        }

      }
    }
    // Do things again that should happen automatically
    sum_reg.update_sum();
    mem_data.set_value ( memory[mem_addr.get_value()] );

    if (control_word.get_bit(iHT)) {
      clock.stop();
      stop();
    }
  }
}

microcode_machine = new MicroCodeMachine();

var count = 0;
function exec_next() {

  /* Bus:
       Have the bus include an "in use" (iu) bit.
       At the beginning of a microinstruction (ui), the "iu" bit is cleared.
       Every time anything is written to the bus, the "iu" bit is checked.
       If the "iu" bit was set before writing, then bus contention exists.
       If the "iu" bit wasn't set, then it is set upon writing.
       The order of register changes within a single "ui" should not matter.
  */

  // Toggle the clock
  clock.half_tick();

  if (execution_mode.get_mode_name() == "micro2") {
    console_log ( "micro2" + " mode" );
    console_log ( "micro2 not implemented yet" );
    // control_word.randomize_bits();
    microcode_machine.exec_next();
  } else if (execution_mode.get_mode_name() == "micro1") {
    // Execucte micro instructions step by step
    console_log ( "micro1" + " mode" );
    ucode_ctr.update ( clock.get_state() );
    if (clock.get_state()) {
      let ucode_step = ucode_ctr.get_value();
      console_log ( "ucode step: " + ucode_step );
      if (ucode_step == 0) {
        // Always fetch
        // MI = Memory Address Register In
        // CE = Program Counter Enabled
        console_log ( "PC to MAR" );
        control_word.set_value ( MI | CE );
        bus.set_value ( prog_ctr.get_value() );
        mem_addr.set_value ( bus.get_value() );
        mem_data.set_value ( memory[mem_addr.get_value()] );
      } else if (ucode_step == 1) {
        // Always move from memory into the Instruction Register
        // RO = RAM Out
        // II = Instruction Register In
        // CE = Program Counter Enabled
        console_log ( "RAM to Instruction Register" );
        control_word.set_value ( RO | II | CE );
        let ram = memory[mem_addr.get_value()];
        bus.set_value ( ram );
        inst_op.set_value ( (ram >> 4) & 0x0f );
        inst_data.set_value ( ram & 0x0f );
        prog_ctr.set_value ( (prog_ctr.get_value() + 1) % 16 );
      } else {
        // Look at the instruction and step
        let operation = inst_op.get_value();
        let operand = inst_data.get_value();
        console_log ( "uExecute " + operation.toString(16) + "" + operand.toString(16) );
        if (operation == 0x00)        { // "NOP " + operand );
          console_log ( "Executing NOP " + operand + " at step " + ucode_step );
          // Do nothing
          control_word.set_value ( 0 );
        } else if (operation == 0x01) { // "LDA " + operand );
          console_log ( "Executing LDA " + operand );
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
            mem_data.set_value ( memory[mem_addr.get_value()] );
          } else if (ucode_step == 3) {
            // RO = RAM Out
            // AI = A Register In
            console_log ( "Move RAM to A" );
            control_word.set_value ( RO | AI );
            bus.set_value ( memory[mem_addr.get_value()] );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x02) { // "ADD " + operand );
          console_log ( "Executing ADD " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  1  0  0  1  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  0  0  0  0  0 0  1
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
            mem_data.set_value ( memory[mem_addr.get_value()] );
          } else if (ucode_step == 3) {
            // RO = RAM Out
            // BI = B Register In
            console_log ( "Move RAM to B" );
            control_word.set_value ( RO | BI );
            bus.set_value ( memory[mem_addr.get_value()] );
            b_reg.set_value ( bus.get_value() );
          } else if (ucode_step == 4) {
            // AI = A Register In
            // EO = Sum Out (E looks like sigma)
            // FI = Flags In
            console_log ( "Add put in A" );
            control_word.set_value ( AI | EO | FI );
            let result = a_reg.get_value() + b_reg.get_value();
            if (result > 0xff) {
              carry_bit.set_value ( 1 );
            } else {
              carry_bit.set_value ( 0 );
            }
            if (result == 0) {
              zero_bit.set_value ( 1 );
            } else {
              zero_bit.set_value ( 0 );
            }
            result = result & 0xff;
            sum_reg.set_value ( result );
            bus.set_value ( result );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x03) { // "SUB " + operand );
          console_log ( "Executing SUB " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  1  0  0  1  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
            mem_data.set_value ( memory[mem_addr.get_value()] );
          } else if (ucode_step == 3) {
            // RO = RAM Out
            // BI = B Register In
            console_log ( "Move RAM to B" );
            control_word.set_value ( RO | BI );
            bus.set_value ( memory[mem_addr.get_value()] );
            b_reg.set_value ( bus.get_value() );
          } else if (ucode_step == 4) {
            // AI = A Register In
            // EO = Sum Out (E looks like sigma)
            // FI = Flags In
            // SU = Subtract Signal
            console_log ( "Subtract put in A" );
            control_word.set_value ( AI | EO | FI | SU );
            let result = a_reg.get_value() - b_reg.get_value();
            if (result >= 0x00) {
              carry_bit.set_value ( 1 );
            } else {
              carry_bit.set_value ( 0 );
            }
            if (result == 0) {
              zero_bit.set_value ( 1 );
            } else {
              zero_bit.set_value ( 0 );
            }
            result = result & 0xff;
            sum_reg.set_value ( result );
            bus.set_value ( result );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x04) { // "STA " + operand );
          console_log ( "Executing STA " + operand );
          if (ucode_step == 2) {
            // MI = Memory Address Register In
            // IO = Instruction Register Out
            console_log ( "Move InstData to MAR" );
            control_word.set_value ( MI | IO );
            bus.set_value ( inst_data.get_value() );
            mem_addr.set_value ( bus.get_value() );
            mem_data.set_value ( memory[mem_addr.get_value()] );
          } else if (ucode_step == 3) {
            // RI = RAM In
            // AO = A Register Out
            console_log ( "Move A to RAM" );
            control_word.set_value ( RI | AO );
            bus.set_value ( a_reg.get_value() );
            memory[mem_addr.get_value()] = bus.get_value();
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x05) { // "LDI " + operand );
          console_log ( "Executing LDI " + operand );
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // AI = A Register In
            console_log ( "Move InstData to A" );
            control_word.set_value ( IO | AI );
            bus.set_value ( inst_data.get_value() );
            a_reg.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x06) { // "JMP " + operand );
          console_log ( "Executing JMP " + operand );
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // J  = Jump
            console_log ( "Move InstData to PC" );
            control_word.set_value ( IO | J );
            bus.set_value ( inst_data.get_value() );
            prog_ctr.set_value ( bus.get_value() );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x07) { // "JC  " + operand );
          console_log ( "Executing JC " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  0  0  0  0  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // J  = Jump
            if (carry_bit.get_value() == 0) {
              console_log ( "No Carry No Jump" );
              control_word.set_value ( 0 );
            } else {
              console_log ( "Jump on Carry" );
              control_word.set_value ( IO | J );
              bus.set_value ( inst_data.get_value() );
              prog_ctr.set_value ( bus.get_value() );
            }
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x08) { // "JZ  " + operand );
          console_log ( "Executing JZ " + operand );
          // HT MI RI RO IO II AI AO EO SU BI OI CE CO J FI
          //  0  0  0  0  0  0  0  0  0  0  0  0  0  0 0  0
          //  0  0  0  1  0  0  0  0  0  0  1  0  0  0 0  0
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          //  0  0  0  0  0  0  1  0  1  1  0  0  0  0 0  1
          if (ucode_step == 2) {
            // IO = Instruction Register Out
            // J  = Jump
            if (zero_bit.get_value() == 0) {
              console_log ( "No Zero No Jump" );
              control_word.set_value ( 0 );
            } else {
              console_log ( "Jump on Zero" );
              control_word.set_value ( IO | J );
              bus.set_value ( inst_data.get_value() );
              prog_ctr.set_value ( bus.get_value() );
            }
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x09) { // "?09 " + operand );
          console_log ( "Executing ?9 " + operand );
        } else if (operation == 0x0a) { // "?0A " + operand );
          console_log ( "Executing ?A " + operand );
        } else if (operation == 0x0b) { // "?0B " + operand );
          console_log ( "Executing ?B " + operand );
        } else if (operation == 0x0c) { // "?0C " + operand );
          console_log ( "Executing ?C " + operand );
        } else if (operation == 0x0d) { // "?0D " + operand );
          console_log ( "Executing ?D " + operand );
        } else if (operation == 0x0e) { // "OUT " + operand );
          console_log ( "Executing OUT " + operand );
          if (ucode_step == 2) {
            // AO = A Register Out
            // OI = Output Register In
            control_word.set_value ( AO | OI );
            bus.set_value ( a_reg.get_value() );
            display_out.set_value ( bus.get_value() );
            if (debugging) {
              console.log ( "OUT: " + bus.get_value() );
            }
            display_out.set_digits ( String(bus.get_value()) );
          } else {
            control_word.set_value ( 0 );
          }
        } else if (operation == 0x0f) { // "FX" Halt instruction ("HLT")
          control_word.set_value ( HT );
          clock.stop();
          stop();
        }
      }
    } else {
      // This is the alternate half of the clock cycle
    }

  } else if (execution_mode.get_mode_name() == "macro") {
    console_log ( "macro" + " mode" );

    // Execute macro instructions

    // Update the ucode counter
    ucode_ctr.update ( clock.get_state() );

    if ( clock.get_state() && (ucode_ctr.get_state() == 3) ) {
      // Execute the current instruction
      let pc = prog_ctr.get_value();

      mem_addr.set_value ( pc );
      mem_data.set_value ( memory[pc] );
      let lower = memory[pc] & 0x0f;
      let upper = (memory[pc] >> 4) & 0x0f;

      inst_op.set_value ( upper );
      inst_data.set_value ( lower );

      if (upper == 0x00)        { // "NOP " + lower );
        // Do nothing
      } else if (upper == 0x01) { // "LDA " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        let value = memory[lower];
        a_reg.set_value ( value );
        sum_reg.set_value ( (a_reg.get_value() + b_reg.get_value()) );
      } else if (upper == 0x02) { // "ADD " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        let value = memory[lower];
        b_reg.set_value ( value );
        let result = a_reg.get_value() + b_reg.get_value();
        if (result > 0xff) {
          carry_bit.set_value ( 1 );
        } else {
          carry_bit.set_value ( 0 );
        }
        result = result & 0xff;
        sum_reg.set_value ( result );
        a_reg.set_value ( result );
      } else if (upper == 0x03) { // "SUB " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        let value = memory[lower];
        b_reg.set_value ( value );
        let result = a_reg.get_value() - b_reg.get_value();
        if (result >= 0x00) {
          carry_bit.set_value ( 1 );
        } else {
          carry_bit.set_value ( 0 );
        }
        if (result == 0) {
          zero_bit.set_value ( 1 );
        } else {
          zero_bit.set_value ( 0 );
        }
        result = result & 0xff;
        sum_reg.set_value ( result );
        bus.set_value ( result );
        a_reg.set_value ( bus.get_value() );

      } else if (upper == 0x04) { // "STA " + lower );
        mem_addr.set_value ( lower );
        mem_data.set_value ( memory[lower] );
        memory[lower] = a_reg.get_value();
        sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
      } else if (upper == 0x05) { // "LDI " + lower );
        a_reg.set_value ( lower );
        sum_reg.set_value ( a_reg.get_value() + b_reg.get_value() );
      } else if (upper == 0x06) { // "JMP " + lower );
        mem_addr.set_value ( lower );
        let value = memory[lower];
        mem_data.set_value ( memory[lower] );
        pc = lower - 1; // Jump before destination since pc will be incremented
      } else if (upper == 0x07) { // "JC  " + lower );
        if (carry_bit.get_value() != 0) {
          mem_addr.set_value ( lower );
          mem_data.set_value ( memory[lower] );
          let value = memory[lower];
          pc = lower - 1; // Jump before destination since pc will be incremented
        }
      } else if (upper == 0x08) { // "JZ  " + lower );
        if (zero_bit.get_value() != 0) {
          mem_addr.set_value ( lower );
          mem_data.set_value ( memory[lower] );
          let value = memory[lower];
          pc = lower - 1; // Jump before destination since pc will be incremented
        }
      } else if (upper == 0x09) { // "?09 " + lower );
      } else if (upper == 0x0a) { // "?0A " + lower );
      } else if (upper == 0x0b) { // "?0B " + lower );
      } else if (upper == 0x0c) { // "?0C " + lower );
      } else if (upper == 0x0d) { // "?0D " + lower );
      } else if (upper == 0x0e) { // "OUT " + lower );
        // Display the A Register as output
        if (debugging) {
          console.log ( "Out = " + a_reg.get_value() );
        }
        display_out.set_digits ( String(a_reg.get_value()) );
      } else if (upper == 0x0f) { // "FX" Halt instruction ("HLT")
        control_word.set_value ( HT );
        clock.stop();
        stop();
      }
      bus.randomize_bits();
      if (upper != 0x0f) { // "FX" Halt instruction ("HLT")
        // Show a random word when not halted
        // control_word.randomize_bits();
      }
      // Increment the program counter as needed
      pc = (pc + 1) % 16;
      prog_ctr.set_value ( pc );
    }
  }

  // Update the canvas to cause a redraw of all changes

  update_canvas();

	count = count + 1;
}


function LDI_test_passed(x) {
  // Verify the correct results from LDI x
  // execution_mode.set_mode ( "micro1" );

  // Set up the test case
  control_word.set_value ( 0 );
  clock.reset_button.reset();
  memory[0] = 0x50 | x; // LDI x
  memory[1] = 0xf0; // HLT
  memory[2] = 0xf0; // HLT
  // Run the processor until halted
  for (let i=0; i<100; i++) {
    exec_next();
    if (control_word.get_value(HT)[0]) {
      break; // Processor halted, so break out of execution loop
    }
  }
  // Verify the result
  if (a_reg.get_value() != x) {
    console.log ( "LDI Test expected A=" + x + ", but got A=" + a_reg.get_value() );
    passed = false;
    return ( false ); // Failed result, so return false
  }
  return ( true );
}

function ADD_test_passed(i,j) {
  // Verify the correct results from i+j
  // execution_mode.set_mode ( "micro1" );

  // Set up the test case
  control_word.set_value ( 0 );
  clock.reset_button.reset();
  memory[0] = 0x14; // LDA 4
  memory[1] = 0x25; // ADD 5
  memory[2] = 0xf0; // HLT
  memory[3] = 0xf0; // HLT
  memory[4] = 0x00 | i; // Value of i
  memory[5] = 0x00 | j; // Value of j
  // Run the processor until halted
  for (let i=0; i<100; i++) {
    exec_next();
    if (control_word.get_value(HT)[0]) {
      break; // Processor halted, so break out of execution loop
    }
  }
  // Verify the result
  if (a_reg.get_value() != ((i+j)&0xff)) {
    console.log ( "ADD Test (" + i + "+" + j + ") expected A=" + (i+j) + ", but got A=" + a_reg.get_value() );
    return ( false );
  }
  // Verify the carry bit
  let expected_carry = 0;
  if (i+j > 255) {
    expected_carry = 1;
  }
  if (carry_bit.get_value() != expected_carry) {
    console.log ( "ADD Test (" + i + "+" + j + ") expected C=" + expected_carry + ", but got C=" + carry_bit.get_value() );
    return ( false );
  }
  // Verify the zero bit
  let expected_zero = 0;
  if (i+j == 0) {
    expected_zero = 1;
  }
  if (zero_bit.get_value() != expected_zero) {
    console.log ( "ADD Test (" + i + "+" + j + ") expected Z=" + expected_zero + ", but got Z=" + zero_bit.get_value() );
    return ( false );
  }
  return ( true );
}

function SUB_test_passed(i,j) {
  // Verify the correct results from i-j
  // execution_mode.set_mode ( "micro1" );

  // Set up the test case
  control_word.set_value ( 0 );
  clock.reset_button.reset();
  memory[0] = 0x14; // LDA 4
  memory[1] = 0x35; // SUB 5
  memory[2] = 0xf0; // HLT
  memory[3] = 0xf0; // HLT
  memory[4] = 0x00 | i; // Value of i
  memory[5] = 0x00 | j; // Value of j
  // Run the processor until halted
  for (let i=0; i<100; i++) {
    exec_next();
    if (control_word.get_value(HT)[0]) {
      break; // Processor halted, so break out of execution loop
    }
  }
  // Verify the result
  if (a_reg.get_value() != ((i-j)&0xff)) {
    console.log ( "SUB Test (" + i + "-" + j + ") expected A=" + (i-j) + ", but got A=" + a_reg.get_value() );
    return ( false );
  }
  // Verify the carry bit
  let expected_carry = 0;
  if (i-j >= 0) {
    expected_carry = 1;
  }
  if (carry_bit.get_value() != expected_carry) {
    console.log ( "SUB Test (" + i + "-" + j + ") expected C=" + expected_carry + ", but got C=" + carry_bit.get_value() );
    return ( false );
  }
  // Verify the zero bit
  let expected_zero = 0;
  if (i-j == 0) {
    expected_zero = 1;
  }
  if (zero_bit.get_value() != expected_zero) {
    console.log ( "SUB Test (" + i + "-" + j + ") expected Z=" + expected_zero + ", but got Z=" + zero_bit.get_value() );
    return ( false );
  }
  return ( true );
}

function processor_test() {
  // This function can test execution of instructions
  execution_mode.set_mode ( "micro1" ); // macro micro1 micro2 (Note: tests currently only pass using micro1)

  let passed = false;

  // Run LDI tests:
  for (let x=0; x<16; x++) {
    console.log ( "LDI Test " + x );
    passed = LDI_test_passed(x);
    if (passed == false) {
      return ( false );
    }
  }

  // Run edge cases for SUB
  let sub_cases = [ [0,0], [0,1], [1,1], [0xfe,1], [0xfe,2], [0xff,0], [0xff,1], [0xff,2], [0xff,0xff] ];
  for (let i=0; i<sub_cases.length; i++) {
    console.log ( "SUB Test: " + sub_cases[i][0] + " - " + sub_cases[i][1] );
    passed = SUB_test_passed(sub_cases[i][0],sub_cases[i][1]);
    if (passed == false) {
      return ( false );
    }
    console.log ( "SUB Test: " + sub_cases[i][1] + " - " + sub_cases[i][0] );
    passed = SUB_test_passed(sub_cases[i][1],sub_cases[i][0]);
    if (passed == false) {
      return ( false );
    }
  }
  // Test sample cases for SUB across the range of inputs
  for (let x=0; x<256; x+=17) {
    for (let y=0; y<256; y+=11) {
      console.log ( "SUB Test: " + x + " - " + y );
      passed = SUB_test_passed(x,y);
      if (passed == false) {
        return ( false );
      }
      console.log ( "SUB Test: " + y + " - " + x );
      passed = SUB_test_passed(y,x);
      if (passed == false) {
        return ( false );
      }
    }
  }
  // Test SUB for randomly chosen sample cases
  for (let i=0; i<1000; i++) {
    let x = Math.floor ( 255 * Math.random() );
    if (x > 255) x = 255;
    let y = Math.floor ( 255 * Math.random() );
    if (y > 255) y = 255;
    console.log ( "SUB Test: " + x + " - " + y );
    passed = SUB_test_passed(x,y);
    if (passed == false) {
      return ( false );
    }
    console.log ( "SUB Test: " + y + " - " + x );
    passed = SUB_test_passed(y,x);
    if (passed == false) {
      return ( false );
    }
  }

  // Run edge cases for ADD
  let add_cases = [ [0,0], [0,1], [1,1], [0xfe,1], [0xfe,2], [0xff,0], [0xff,1], [0xff,2], [0xff,0xff] ];
  for (let i=0; i<add_cases.length; i++) {
    console.log ( "ADD Test: " + add_cases[i][0] + " + " + add_cases[i][1] );
    passed = ADD_test_passed(add_cases[i][0],add_cases[i][1]);
    if (passed == false) {
      return ( false );
    }
    console.log ( "ADD Test: " + add_cases[i][1] + " + " + add_cases[i][0] );
    passed = ADD_test_passed(add_cases[i][1],add_cases[i][0]);
    if (passed == false) {
      return ( false );
    }
  }
  // Test sample cases for ADD across the range of inputs
  for (let x=0; x<256; x+=17) {
    for (let y=0; y<256; y+=11) {
      console.log ( "ADD Test: " + x + " + " + y );
      passed = ADD_test_passed(x,y);
      if (passed == false) {
        return ( false );
      }
      console.log ( "ADD Test: " + y + " + " + x );
      passed = ADD_test_passed(y,x);
      if (passed == false) {
        return ( false );
      }
    }
  }
  // Test ADD for randomly chosen sample cases
  for (let i=0; i<1000; i++) {
    let x = Math.floor ( 255 * Math.random() );
    if (x > 255) x = 255;
    let y = Math.floor ( 255 * Math.random() );
    if (y > 255) y = 255;
    console.log ( "ADD Test: " + x + " + " + y );
    passed = ADD_test_passed(x,y);
    if (passed == false) {
      return ( false );
    }
    console.log ( "ADD Test: " + y + " + " + x );
    passed = ADD_test_passed(y,x);
    if (passed == false) {
      return ( false );
    }
  }

  return ( true );
}


function cpu_reset() {
	is_idle = false;
	running = true;
	stop_running = true;
	run_stop();
	stop();
	run_counter = 1;
	main_loop.main_loop_counter = 0;
	ucode_ctr.reset();
	update_canvas();
}

function reset_callback() {
  clock.reset_button.reset();
	document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
	document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
	running = false;
}

function run_stop_callback() {
	running = !running;
	if (running) {
		document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
		document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
		clock.run();
		run();
	} else {
		document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
		document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
		clock.stop();
		stop();
	}
	update_canvas();
}

function on_help_change() {
  // window.alert ( "Help changed" );

	let selector = document.getElementById("show_help");
	let setting = selector[selector.selectedIndex].value;
	console_log ( "Help setting = " + setting );
	let n = selector.options.length;
	console_log ( "There are " + n + " options" );
	for (let i=0; i<n; i++) {
	  let ith_id = selector.options[i].value;
	  if (ith_id == setting) {
	    console_log ( "Setting " + ith_id + ".hidden = false" );
	    document.getElementById(ith_id).hidden = false;
	  } else {
	    console_log ( "Setting " + ith_id + ".hidden = true" );
	    document.getElementById(ith_id).hidden = true;
	  }
	}
}


window.onload = setup_canvas;

setup_canvas();

</script>

</head>

<body id='page' onload="setup_canvas()" onresize="update_canvas()" bgcolor="lightblue">

<center>
<b>Simulation of <a href="https://eater.net/8bit">Ben Eater's 8-bit Computer</a></b><br/>

<table>

<tr>

<td>
<canvas id="drawing_area" onmousedown="mouse_down(event)" onmouseup="mouse_up(event)"></canvas>
</td>

<td id="status_area" style="border: none;" valign="top">
<center>
Processor<br/>
<button type="button" onclick="run_stop_callback();" id="RunStop" style="background-color: #99FF99;">Run/<u>Stop</u></button>
<button type="button" onclick="reset_callback();">Reset</button>
</center>
<!-- <pre>-----------------</pre> -->
<pre id="next_instruction">Next goes here.
</pre>
<p></p>
<pre id="mem_status">Memory goes here.
</pre>
</td>

<td style="border: none;" valign="top">
<center>
Hex Code<br/>
<button type="button" onclick="load_hex()">Load</button><br/>
<textarea id="Hex Code" rows="20" cols="3">51
4E
50
2E
4F
1E
4D
1F
4E
1D
E0
70
63
00
00
00</textarea><br/>
<button type="button" onclick="zero_hex()">Zeros</button><br/>
</center>
</td>

<td style="border: none;" valign="top">
<center>
Source Code<br/>
<button type="button" onclick="assemble()">Assemble</button><br/>
<textarea id="Source Code" rows="20" cols="20">0 LDI 1
1 STA E
2 LDI 0
3 ADD E
4 STA F
5 LDA E
6 STA D
7 LDA F
8 STA E
9 LDA D
A OUT
B JC 0
C JMP 3
D 0
E 0
F 0</textarea>
<br/>
<select id="examples" onchange="change_example()">
<option value="Examples">Examples</option>
<option value="NOP HLT">NOP HLT</option>
<option value="Add Sub">Add Sub</option>
<option value="Add 14+28">Add 14+28</option>
<option value="Counter">Counter</option>
<option value="CountUpDown">Count U/D</option>
<option value="Fibonacci">Fibonacci</option>
<option value="Mult 3x5">Multiply 3x5</option>
<option value="Mult 7x8">Multiply 7x8</option>
<option value="Mult 15x15">Multiply 15x15</option>
<option value="Line Nums">Line Numbers</option>

<!-- <option value="Multiply">Multiply: E x F</option> May not work yet -->
</select>
<br/><input type="checkbox" id="Debugging" onclick="toggle_debugging();">Debug
</center>
</td>

</tr>
</table>
</center>


<hr/>
<center><span id="info_title">Additional Information</span> &nbsp; &nbsp; &nbsp; &nbsp; 
<select id="show_help" onchange="on_help_change()">
<option value="none" selected>-- Select --</option>
<option value="introduction">Introduction</option>
<option value="instruction_set">Instruction Set</option>
</select>
<button type="button" onclick="on_help_change();">Load</button><center>
<hr/>



<div id="none" hidden></div>
<div id="introduction" hidden>
<center>
<h3>Introduction</h3>
</center>
This simulation attempts to replicate the operation of <b><a href="https://eater.net/8bit">Ben Eater's 8-bit Computer</a></b>.
This simulation contains buttons and dip switches similar to those on Ben's computer.
</div>

<div id="instruction_set" hidden>
<center>
<h3>Instruction Set (a=address, v=value, x=don't care)</h3>
</center>
<table>
<tr><td><b>Name</b></td><td><b>Hex</b></td><td><b>Binary</b></td><td><b>Description</b></td></tr>
<tr><td>NOP</td><td>0x</td><td>0000 xxxx</td><td>No operation (does nothing)</td></tr>
<tr><td>LDA</td><td>1a</td><td>0001 addr</td><td>Load from memory (addr) into A Register</td></tr>
<tr><td>ADD</td><td>2a</td><td>0010 addr</td><td>Add from memory (addr) into A Register</td></tr>
<tr><td>SUB</td><td>3a</td><td>0011 addr</td><td>Subtract memory (addr) from A Register</td></tr>
<tr><td>STA</td><td>4a</td><td>0100 addr</td><td>Store to memory (addr) from A Register</td></tr>
<tr><td>LDI</td><td>5v</td><td>0101 value</td><td>Load immediate value into A Register</td></tr>
<tr><td>JMP</td><td>6a</td><td>0110 addr</td><td>Jump immediate</td></tr>
<tr><td>JC </td><td>7a</td><td>0111 addr</td><td>Jump on carry immediate</td></tr>
<tr><td>JZ </td><td>8a</td><td>1000 addr</td><td>Jump on zero immediate</td></tr>
<tr><td>---</td><td>9?</td><td>1001 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>A?</td><td>1010 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>B?</td><td>1011 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>C?</td><td>1100 ???? </td><td>Not defined</td></tr>
<tr><td>---</td><td>D?</td><td>1101 ???? </td><td>Not defined</td></tr>
<tr><td>OUT</td><td>Ex</td><td>1110 xxxx</td><td>Output to LED panel (could use XXXX for In/Out channels)</td></tr>
<tr><td>HLT</td><td>Fx</td><td>1111 xxxx</td><td>Halt (could use XXXX for other instructions, push, pop, chs, etc.)</td></tr>
</table>
</div>

</body>
</html>

